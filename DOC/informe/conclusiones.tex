\chapter*{Conclusiones}
%
%
Después de analizar, diseñar e implementar queda como ultima tarea la de exponer la experiencia que resulto de todo el trabajo echo, como introducción se puede destacar que se tomo verdadera conciencia de lo que implica analizar un problema antes de iniciar con un proyecto aun cuando este no sea muy grande, a la hora de diseñar e implementar dada la poca o nula experiencia la tarea estuvo mezclada pues algunos detalles de diseño, debido a la naturaleza de el proyecto, requerían mayor conocimientos sobre el lenguaje de los que inicialmente se poseían, además de otros conceptos mucho mas abstractos como por ejemplo los de los patrones y de las buenas practicas a la hora de desarrollar o mejor dicho escribir código.
%
%
\section{Resultado de el proyecto}
%
\jj es un paquete sencillo que pesa aproximadamente 69$kb$ cuando es empaquetado y además liviano en términos de sobrecarga de CPU, pero a pesar de este ``liviandad'' cumple con todas las necesidades que se plantearon inicialmente en el proyecto y de una manera bastante sencilla de utilizar para todo aquel que tenga un conocimiento básico de SQL pues los métodos fueron nombrados acorde a dicho lenguaje, además de esto tiene mínimas dependencias de otras librerías requiriendo tan solo de \jd y de el driver correspondiente a el motor que se quiera utilizar. Para empezar a usarlo solamente requiere que se le informe de una URI hacia la base de datos junto con los credenciales de acceso correspondientes y ya es posible empezar a hacer consultas o actualizaciones sobre la base de datos\footnote{Siempre que el motor con el que se quiere trabajar este soportado}, el paquete se encargara por detrás de lidiar con \jd para evitar algunas tareas repetitivas a el programador y además provee una sintaxis propia implementada en el API de el manejador de sentencias que abstrae el uso de dialectos SQL específicos de los motores que están soportados.

La liviandad que se busco tanto en tamaño físico como de carga extra de recursos tiene también su lado malo, puesto que simplicidad puede traducirse en menos opciones tanto de uso como de configurabilidad:
%
\begin{itemize}
\item \textbf{\jd}: en orden de hacer ocultar el uso de \jd y de proveer una interfaz mucho mas simple se ocultan muchas de las funcionalidades de el mismo, pero también muchas de estas posibilidades están fuera de el alcance actual de este proyecto.
%
\item \textbf{Manejo de los datos extraídos}: dado que \jd ya provee una manera independiente de el DB que se este utilizando para acceder a los datos que se obtuvieron de una consulta, este aspecto no es cubierto directamente por \jj si no que utiliza \verb=ResultSet= que es la interfaz que provee dicha API, por lo que es necesario conocer el uso de esta interfaz para poder utilizar los datos extraídos desde el DB.
%
\item \textbf{Control de errores}: en el manejador de sentencias solo se controlan los errores mas triviales que puedan ocurrir cuando no se respeta la sintaxis de creación de sentencias, esto evita controles redundantes puesto que el DBMS al recibir la sentencia vuelve a controlar los errores. En el lado de la capa de abstracción de \jd los errores no deben ser manejados si no que deben ser relanzados, en este sentido la depuración de el programa puede resultar mas compleja que si se utilizara únicamente el API de Java.
%
\item \textbf{API simplificada}: hay demasiados configuraciones posibles para las sentencias SQL por lo que no se cubren algunos aspectos principalmente con el uso de funciones, hay tantas diferencias entre las mismas que no es factible entregar un API que las contemple a todas ellas sin caer en la dependencia de un motor en especifico.
%
\item \textbf{Sintaxis genérica}: la sintaxis en común que se definió entre los tres motores a los que se le esta dando soporte limita mucho las capacidades de los diferentes motores, esto debido principalmente a la presencia de \s entre los motores puesto que este es un motor minimalista que no tiene muchas de las características que los otros si, aun así algunas de estas características pueden ser implementadas si se las ``programa'' por cuenta propia pero esto ya implicaría que se debe realizar trabajo extra para migrar de motor y por lo tanto se perdería independencia. 
\end{itemize}
%
%
%
\section{Conclusiones generales}    
%
Mas allá de que el principal objetivo de este trabajo sea demostrar los conocimientos adquiridos sobre programación durante el cursado de la carrera de Computador Universitario es inevitable caer (pensando exclusivamente en un programador) en las tareas de análisis y diseño debido a que el proyecto es relativamente grande y es en si una tarea necesaria en el desarrollo de software pero que a veces se hace de manera implícita si es que la aplicación es lo suficientemente pequeña. Y fue ese el problema inicial al desarrollar este proyecto, no considerar el tamaño de el proyecto y por lo tanto no tomar real conciencia de la importancia de el análisis y posterior diseño hasta que se llego al punto en que se tenia una estructura básica funcional pero no se sabia como avanzar debido a que no se poseía total conocimiento de los requisitos de el proyecto por que el análisis inicial fue muy rudimentario o como anteriormente exprese fue una tarea implícita, pues no se encaro el análisis como tal si no que fue de una manera mas artesanal. Por lo que las tareas de análisis y diseño inicialmente fueron relegadas a segundo plano quedando como tarea primordial la codificación hasta el punto en el que ya no se sabia como continuar por que no se sabia que faltaba además en este punto ya se había incluido una librería externa que servía como base para el desarrollo de el manejador de sentencias la cual ayudo también a evitar realizar explícitamente tareas de diseño, fue entonces que se tomo en cuenta la importancia de la necesidad de el análisis y diseño y mas en este tipo de desarrollo donde se deben contemplar muchas pequeñas características que no pueden ser descubiertas a menos que se la explicite y mas aun por que para obtener los requisitos de el sistema es necesario estudiar documentación existente de diferentes proveedores.

El párrafo anterior trata en definitiva de un problema de metodología de desarrollo mas específicamente de la inexistencia inicial de metodología de desarrollo aplicada a el proyecto, principalmente por lo nula experiencia con este tipo de metodologías y secundariamente por que no se exigía uso de metodología alguna aunque claro se lo puede tomar como un requisito implícito. Como principal experiencia de este aspecto de el desarrollo concluyo que es un requisito necesario que el programador además de tener experiencia en el manejo de un lenguaje debe tener experiencia en metodologías de desarrollo, y lastimosamente a mi comprender solo se toma real conciencia de esto cuando se esta en frente a proyectos relativamente grandes con limitado tiempo de desarrollo.

Mas allá de los problemas de análisis, diseño o implementación que se comentaron
el mayor desafío al que me  enfrente en el desarrollo del proyecto fue la dificultad al decidir como diseñar las clases en si\footnote{ver la sección \ref{implementacion:manejador:facilitando} de el capitulo de Implementación} mas que la arquitectura que conformaban entre ellas pues es muy distinto escribir código que sera usado para escribir más código, que código que no sera directamente utilizado, por ejemplo se podrían obviar las buenas practicas a la hora de implementar un sistema eminentemente visual o mejor dicho una herramienta para uso final, un programa cualquiera, pues el usuario no ve directamente el código para el esta todo bien si es que la interfaz responde o se adecua a sus necesidades, pero a la hora de escribir una librería por ejemplo es la sintaxis que se usa, los métodos que se ponen a disponibilidad, la facilidad de uso que se da la que ponen en juego la utilidad o complacencia del usuario programador frente a el trabajo realizado. Este echo me demostró la importancia de seguir estándares (convenciones o buenas practicas) a la hora de desarrollar pues ello hace que sea mas amigable la lectura, mantenibilidad y en este caso usabilidad de el código que aunque es interpretado por maquinas debe ser desarrollado, al menos por ahora, por humanos.

Finalmente el trabajar en este proyecto profundizo mis conocimientos sobre JSE\footnote{\textit{Java Standard Edition}} y además sirve como un futuro puntapié para adentrarse en el mundo de JEE\footnote{\textit{Java Enterprise Edition}} recordando que ambos son SDK de Java pero orientados a sectores diferentes. El estudio de los diferentes motores que soporta este proyecto también sirven como punto de partida para una mayor profundización en el uso o elección de los mismos en proyectos futuros. Y como ultima y mas importante experiencia rescato mas allá de lo aprendido sobre las tecnologías que se usaron los conocimientos abstractos que luego se pueden extrapolar a otras situaciones como por ejemplo el uso de patrones de desarrollo y un mayor conocimiento y experiencia con POO.