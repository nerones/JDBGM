\chapter*{\addcontentsline{toc}{chapter}{Conclusiones}Conclusiones}
%
%
Después de analizar, diseñar e implementar queda como ultima tarea la de exponer la experiencia que resulto de todo el trabajo echo, como introducción se puede destacar que se tomo verdadera conciencia de lo que implica analizar un problema antes de iniciar con un proyecto aun cuando este no sea muy grande.% Resultado de la poca importancia (y experiencia) inicial el diseño, análisis e implementación se realizaron  estuvo mezclada pues algunos detalles de diseño, debido a la naturaleza del proyecto, requerían mayor conocimientos sobre el lenguaje de los que inicialmente se poseían, además de otros conceptos mucho mas abstractos como por ejemplo los de los patrones y de las buenas practicas a la hora de escribir código.
%
%
\section{Resultado de el proyecto}
%
\jj es un paquete ``liviano'' tanto en tamaño, pesa aproximadamente 69$kb$ cuando es empaquetado, como en términos de carga de CPU, pero a pesar de este ``liviandad'' cumple con todas las necesidades que se plantearon inicialmente en el proyecto de una manera bastante sencilla de utilizar para todo aquel que tenga un conocimiento básico de SQL\footnote{Pues los métodos fueron nombrados acorde a dicho lenguaje}. Además de esto tiene mínimas dependencias de otras librerías requiriendo tan solo de \jd y del driver correspondiente a el motor que se quiera utilizar. Para empezar a usarlo solamente requiere que se le informe de una URI hacia la base de datos que se quiere utilizar junto con los credenciales de acceso correspondientes y ya es posible empezar a hacer consultas o actualizaciones sobre dicha base de datos\footnote{Siempre que el motor con el que se quiere trabajar este soportado}. El paquete se encargara por detrás de lidiar con \jd para evitar algunas tareas repetitivas a el programador y además provee una sintaxis propia implementada en el API del manejador de sentencias que abstrae el uso de dialectos SQL específicos de los motores que están soportados.

La liviandad que se busco tanto en tamaño físico como de carga extra de recursos tiene también su lado discutible, puesto que simplicidad puede traducirse en menos opciones tanto de uso como de configuración:
%
\begin{itemize}
\item \textbf{\jd}: en orden de ocultar el uso de \jd y de proveer una interfaz mucho mas simple se ocultan muchas de las funcionalidades del mismo, pero también muchas de estas posibilidades están fuera del alcance actual de este proyecto.
%
\item \textbf{Manejo de los datos extraídos}: dado que \jd ya provee una manera independiente del \dd que se este utilizando para acceder a los datos que se obtuvieron de una consulta este aspecto no es cubierto directamente por \jj si no que utiliza \verb=ResultSet= que es la interfaz que provee \jj, por lo que es necesario conocer el uso de esta interfaz para poder utilizar los datos extraídos desde el \dd.
%
\item \textbf{Control de errores}: en el manejador de sentencias solo se controlan los errores mas triviales que puedan ocurrir cuando no se respeta la sintaxis de creación de sentencias, esto evita controles redundantes puesto que el DBMS al recibir la sentencia vuelve a controlar los errores. En el lado de la capa de abstracción de \jd los errores no deben ser manejados si no que deben ser relanzados, en este sentido la depuración del programa puede resultar mas compleja que si se utilizara únicamente el API de Java.
%
\item \textbf{API simplificada}: hay demasiados configuraciones posibles para las sentencias SQL por lo que no se cubren algunos aspectos principalmente con el uso de funciones, hay tantas diferencias entre las mismas que no es factible entregar un API que las contemple a todas ellas sin caer en la dependencia de un motor en especifico.
%
\item \textbf{Sintaxis genérica}: la sintaxis en común que se definió entre los tres motores a los que se le esta dando soporte limita mucho las capacidades de los diferentes motores, esto debido principalmente a la presencia de \s entre los motores puesto que este es un motor minimalista que no tiene muchas de las características que los otros si, aun así algunas de estas características pueden ser implementadas si se las ``programa'' por cuenta propia pero esto ya implicaría que se debe realizar trabajo extra para migrar de motor y por lo tanto se perdería independencia. 
\end{itemize}
%
%
%
\section{Conclusiones generales}    
%
Mas allá de que el principal objetivo de este trabajo sea demostrar los conocimientos adquiridos sobre programación durante el cursado de la carrera de Computador Universitario, es inevitable caer (pensando exclusivamente en un programador) en las tareas de análisis y diseño debido a que el proyecto es relativamente grande y es en si una tarea necesaria en el desarrollo de cualquier software, pero que a veces se hace de manera implícita si es que la aplicación es lo suficientemente pequeña. Y fue ese el problema inicial al desarrollar este proyecto, no considerar el tamaño del proyecto y por lo tanto no tomar real conciencia de la importancia del análisis y posterior diseño sino hasta que se llego al punto en que se tenia una estructura básica funcional pero no se sabia que faltaba o si esta se ajustaba a las necesidades del proyecto debido a que no se poseía total conocimiento de los requisitos por que el análisis inicial fue muy rudimentario o como anteriormente se expreso fue una tarea que se realizo de manera implícita. Además en medio de ese desarrollo inicial se había incluido una librería externa que servía como base para el desarrollo de el manejador de sentencias, dicha inclusión ayudo también a evitar realizar explícitamente tareas de diseño pues de ella se tomaron las ideas bases del diseño inicial. Entonces cuando ya no se supo que faltaba fue que se tomo en cuenta la importancia de la necesidad del análisis y diseño, y mas en este tipo de desarrollo donde se deben contemplar muchas pequeñas características que no pueden ser descubiertas a menos que se la explicite y mas aun por que para obtener los requisitos del sistema es necesario estudiar documentación existente de diferentes fuentes.

El párrafo anterior trata en definitiva de un problema de metodología de desarrollo mas específicamente de la inexistencia inicial de metodología de desarrollo aplicada a el proyecto, principalmente por lo nula experiencia con este tipo de metodologías y secundariamente por que no se exigía uso de metodología alguna aunque claro se lo puede tomar como un requisito implícito. Como principal experiencia de este aspecto del desarrollo se concluye que es un requisito necesario que el programador además de tener experiencia en el manejo de un lenguaje debe tener experiencia en metodologías de desarrollo, y lastimosamente al parecer de este estudiante solo se toma real conciencia de esto cuando se esta en frente a proyectos relativamente grandes con limitado tiempo de desarrollo\footnote{Aunque para este proyecto los tiempos eran manejados por el propio alumno.}.

Mas allá de los problemas de análisis, diseño o implementación que se comentaron
el mayor desafío que se enfrento en el desarrollo del proyecto fue la dificultad al decidir como diseñar las clases en si\footnote{ver la sección \ref{implementacion:manejador:facilitando} de el capitulo de Implementación} más que la arquitectura que conformaban entre ellas pues es muy distinto escribir código que sera usado para escribir más código, que código que no sera directamente utilizado, por ejemplo se podrían obviar las buenas practicas a la hora de implementar un sistema eminentemente visual o mejor dicho una herramienta para uso final, un programa cualquiera, pues el usuario no ve directamente el código, para el esta todo bien si es que la interfaz responde o se adecua a sus necesidades, pero a la hora de escribir una librería por ejemplo es la sintaxis que se usa, los métodos que se ponen a disponibilidad, la facilidad de uso que se da la que ponen en juego la utilidad o complacencia del usuario programador frente a el trabajo realizado. Este echo demostró la importancia de seguir estándares (convenciones o buenas practicas) a la hora de desarrollar pues ello hace que sea más amigable la lectura, mantenibilidad y en este caso usabilidad del código que aunque es interpretado por maquinas debe ser desarrollado, al menos por ahora, por humanos.
\newpage
Finalmente el trabajar en este proyecto profundizo los conocimientos que se tenían sobre JSE\footnote{\textit{Java Standard Edition}} y además sirven como un futuro puntapié para adentrarse en el mundo de JEE\footnote{\textit{Java Enterprise Edition}}, recordando que ambos son SDK de Java pero orientados a sectores diferentes. El estudio de los diferentes motores que soporta este proyecto también sirven como punto de partida para una mayor profundización en el uso o elección de los mismos en proyectos futuros. Y como ultima y más importante experiencia se rescata que más allá de lo aprendido específicamente sobre las tecnologías utilizadas también se aprendieron muchos conceptos abstractos que luego se pueden extrapolar a otras situaciones, como por ejemplo el uso de patrones de desarrollo y un mayor conocimiento y experiencia en POO.