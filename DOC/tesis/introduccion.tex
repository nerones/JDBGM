\chapter{Introducción}\label{capitulo:intro}
En cualquier sistema informático es común encontrarse con el uso de bases de datos relacionales para manejar, valga la redundancia, los datos que este debe procesar. Estos datos deben ser leídos, actualizados y registrado por el sistema en la base de datos pero el sistema no es el que controla la base de datos si no es el \textit{Sistema de Gestión de Base de Datos} o Motor de base de datos o \dd\footnote{Por sus siglas en ingles} el que controla la base de datos y cualquier acción que se quiera realizar sobre la BD se hace a través de el motor mediante el lenguaje SQL es decir el sistema informático debe comunicarse con el motor de base de datos. 

En el mercado existen muchos \dd relacionales\footnote{Se usara \dd como sinonimo de \textit{RDBMS} a lo largo de todo el texto pero hay que tener en cuenta que \dd es un termino mas generico que no se refiere solo a motores relacionales.} Microsoft SQL Server, MySQL y Oracle son algunos de ellos y cada uno de estos define un dialecto de SQL muy a pesar de que SQL es un estándar de bastante antigüedad, el echo de por que se usan estos dialectos en vez del estándar corresponden a factores que no nos interesa discutir pero podemos nombrar como ejemplo la necesidad de mantener a los clientes atados a un sistema en particular. La comunicación con el motor se hace a través de un "driver" que por lo general es proveído por el desarrollador del motor y es especifico para este dependiendo de la plataforma sobre la que se este trabajando. Entonces al desarrollar un sistema informático que use una base de datos debemos tener en cuenta que exista el ``\textit{driver}'' para el lenguaje de programación que estemos por utilizar y además que al desarrollar con un determinado motor nos estamos atando en cierta medida al uso de este, otro tema importante y ya dejando de lado la ``dependencia'' con un motor tiene que ver con el diseño del sistema y es el modo en el que se accede a los datos en este sentido debemos pensar que el sistema debe concentrarse en los datos y no en como obtener los datos, por ejemplos tomemos el caso de un sistema orientado a objetos de ventas en el que existe una clase \verb=Ventas= que se encarga de gestionar la venta las cuales es necesario que estén registradas en una base de datos, una primera solución sería que dicha clase se encargue de comunicarse con el motor y de grabar los datos lo cual es posible pero se nos presentarían dos cuestiones primero la clase perdería cohesión pues se estaría encargando de tareas extras y segundo que la clase estaría interviniendo con el acceso al motor por lo que esta debería conocer mas cosas de la que debe es decir habría un mayor acoplamiento entre las diferentes clases, estas cuestiones hacen a la facilidad de mantenimiento del software. Una segunda solución seria que otra clase se encargue de realizar la persistencia de los datos, de este modo \verb=Ventas= no tiene que conocer como es que se están persistiendo los datos solo necesita enviarle un mensaje a la otra clase y dejar que ella se encargue del trabajo. El presente trabajo pretende desarrollar en principio una capa de abstracción para manejar distintos motores de bases de datos desde el lenguaje Java ocultando los detalles correspondientes al acceso a cada motor en particular, inicialmente se dará soporte para 3 motores pero  la estructura de el componente permitiría agregar fácilmente soporte para mas motores. El nombre del proyecto es \textit{Java Data Base Generic Manager} o \jj que es como sera referido de aquí en mas.
%
%
\section{Objetivos generales}
El presente proyecto obliga a realizar dos tareas bien distintas, la primera es el estudio de los diferentes \dd para aprender como es que se manejan esos motores y poder conocer tanto las características en común como aquellas en las que difieran, la segunda tarea tiene que ver con estudiar el modo de diseñar el proyecto es decir de que modo estará estructurado \jj para poder permitir una fácil ampliación, un fácil mantenimiento todo esto teniendo en cuenta que el proyecto es mas que una librería pues proporcionara métodos pero a su vez exigirá un modo de implementar. Así podemos enumerar los siguientes objetivos generales del proyecto:
\begin{enumerate}
\item Familiarizarse con la lectura de documentación de proyectos.
\item Investigar sobre el uso de patrones de diseño.
\item Investigar como se diseña una API.
\end{enumerate}
%
\section{Tecnología utilizada}
El proyecto sera desarrollado sobre el lenguaje de programación Java, originalmente desarrollado por la empresa Sun Microsystems pero desde el 2010 paso a manos de Oracle ya que Sun fue adquirida por completo por Oracle, y los motores de base de datos \m, \p y \s a los que inicialmente se les pretende dar soporte en este proyecto. Como herramientas para asistir el desarrollo se utilizara el entorno de desarrollo Eclipse especializado en java que además agrega otras herramientas como por ejemplo la librería de pruebas unitarias JUnit y el sistema de control de versiones Git. Para el desarrollo de este informe se uso Latex junto con el ``IDE'' Texmaker. Todo el proyecto se desarrollo sobre el sistema operativo Ubuntu principalmente por la familiaridad y facilidad de uso de las herramientas que se estaban utilizando sobre este tipo de sistemas, por ejemplo Git fue creado para ser usado en entornos *nix\footnote{Aunque actualmente se lo puede usar en Windows/Linux/Mac}.
%
\section{Contribución de este trabajo}
%
%
%
\section{Organización del trabajo}
%
El presente trabajo se organiza de la siguiente forma. El Capítulo 1 introduce a el objetivo de el trabajo y lo enmarca dentro de una tecnología determinada además de presentar los objetivos generales que se persiguen. El Capítulo 2 expone algunas de las herramientas existentes que resuelven desde distintos enfoques la problemática que ataca este trabajo, nombrando entre ellas ORM, generadores de código y otros. El Capítulo 3 introduce formalmente la problemática que se esta atacando e introduce el concepto de Patrones de Diseño para terminar introduciendo la solución que se propone. En el Capítulo 4 es la especificación formal de la solución que se propone, para ello se divide el proyecto en dos módulos internos, un manejador de sentencias y un API para el acceso a motores de base de datos. El capitulo 5 documenta los aspectos importantes de el diseño sobre el que se construyo el proyecto, siguiendo para ello la división en dos módulos principales. El Capítulo 6 documenta los pormenores, ajustes y correcciones que se tuvieron que hacer durante la implementación de el proyecto y para terminar se comentan el modo en que se realizaron las pruebas sobre el código escrito. Para terminar con los capítulos se escribió una breve reseña sobre los resultados que se obtuvieron de el proyecto y el trabajo a futuro que se espera realizar.

Como Apéndice de la tesis se creo un manual de usuario que cubre los aspectos basicos de uso de la herramienta que se desarrollo y una descripción de una simple aplicación de ejemplo que muestra un uso practico de la herramienta.     



