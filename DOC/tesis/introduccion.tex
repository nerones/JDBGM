\chapter{Introducción}\label{capitulo:intro}
En cualquier sistema informático es común encontrarse con el uso de bases de datos relacionales para manejar, valga la redundancia, los datos que este debe procesar. Estos datos deben ser leídos, actualizados y registrado por el sistema en la base de datos, pero el sistema no es el que controla la base de datos si no que es el \textit{Sistema de Gestión de Base de Datos} o \textit{Motor de base de datos} o \textit{\dd}\footnote{Por sus siglas en ingles} el que controla la base de datos y cualquier acción que se quiera realizar sobre la base de datos se hace a través de el motor mediante el lenguaje SQL es decir el sistema informático debe comunicarse con el motor de base de datos.

En el mercado existen muchos \dd relacionales\footnote{Se usara \dd como sinonimo de \textit{RDBMS} a lo largo de todo el texto pero hay que tener en cuenta que \dd es un termino genérico que no se refiere solo a motores relacionales.} Microsoft SQL Server, MySQL y Oracle son solo algunos de ellos, esta amplia variedad, que tiene sus beneficios, crea un problema de compatibilidades puesto que cada uno de estos motores define un dialecto de SQL particular, muy a pesar de que SQL es un estándar de bastante antigüedad. El echo de por que se usan estos dialectos en vez del estándar corresponden a factores que no nos interesa discutir pero podemos nombrar como ejemplo la necesidad de mantener a los clientes atados a una plataforma en particular.

La comunicación con el motor se hace a través de un "driver" que por lo general es proveído por el desarrollador del motor y es especifico para este dependiendo de la plataforma sobre la que se este trabajando. Entonces al desarrollar un sistema informático que utilice una base de datos, debemos tener en cuenta que exista el ``\textit{driver}'' para el lenguaje de programación que estemos por utilizar y además que al desarrollar con un determinado motor el sistema queda atando en cierta medida al uso de este. Esta dependencia con el motor puede ser minimizada dependiendo de como se diseñe el sistema, en este sentido debemos pensar que el sistema debe concentrarse en los datos y no en como obtener los datos, por ejemplo tomemos el caso de un sistema de ventas, desarrollado bajo POO, en el que existe una clase \verb=Ventas= que se encarga de gestionar las ventas, las cuales es necesario que estén registradas en una base de datos, una primera solución sería que dicha clase se encargue de comunicarse con el motor y de grabar los datos, lo cual es posible pero se nos presentarían dos cuestiones: primero la clase perdería cohesión pues se estaría encargando de tareas extras y segundo la clase estaría interviniendo en el acceso al motor por lo que esta debería conocer mas cosas de la que debe, es decir habría un mayor acoplamiento entre las diferentes clases, estas cuestiones hacen a la dificultad de mantenimiento del software que es una clave importante para la subsistencia del mismo. Una segunda solución seria que otra clase se encargue de realizar la persistencia de los datos, de este modo \verb=Ventas= no tiene que conocer como es que se están persistiendo los datos solo necesita enviarle un mensaje a la otra clase y dejar que ella se encargue del trabajo. En el anterior ejemplo se estaría acentuando la dependencia con un motor en particular a la vez que se crear otros problemas, en cambio en la segunda solución se tiene una menor dependencia y se eliminan algunos problemas de diseño.

El presente trabajo pretende desarrollar en principio una capa de abstracción para manejar distintos motores de bases de datos desde el lenguaje Java ocultando los detalles correspondientes al acceso a cada motor en particular, inicialmente se dará soporte para 3 motores pero  la estructura de el componente permitiría agregar fácilmente soporte para mas motores. El nombre del proyecto es \textit{Java Data Base Generic Manager} o \jj que es como sera referido de aquí en mas.
%
%
\section{Objetivos generales}
El presente proyecto precisa que se realicen dos tareas básicas bien distintas, la primera es el estudio de los diferentes \dd para aprender como es que se manejan esos motores y poder conocer tanto las características en común como aquellas en las que difieran, la segunda tarea tiene que ver con estudiar el modo de diseñar el proyecto, es decir de que modo estará estructurado \jj para poder permitir una fácil ampliación y un fácil mantenimiento. Así podemos enumerar los siguientes objetivos generales del proyecto:
\begin{enumerate}
\item Familiarizarse con la lectura de documentación de proyectos.
\item Investigar sobre el uso de patrones de diseño.
\item Investigar como se diseña una API\footnote{\textit{Application Programming Interface}}.
\end{enumerate}
%
\section{Tecnología utilizada}
El proyecto sera desarrollado sobre el lenguaje de programación Java y los motores de base de datos \m, \p y \s que son a los que inicialmente se les pretende dar soporte. Como herramientas para asistir el desarrollo se utilizara el entorno de desarrollo Eclipse que esta especializado en java y que además agrega otras herramientas como por ejemplo la librería de pruebas unitarias JUnit y por otro lado se usara el sistema de control de versiones Git que a pesar de que se puede integrar en Eclipse, se prefirió manejarlo de manera separada para poder aprender de manera mas profunda su uso. Para el desarrollo de este informe se uso Latex junto con el ``IDE'' Texmaker. Todo el proyecto se desarrollo sobre el sistema operativo Ubuntu principalmente por la familiaridad y facilidad de uso de las herramientas que se están utilizando sobre este tipo de sistemas, por ejemplo Git fue creado para ser usado en entornos *nix\footnote{Aunque actualmente se lo puede usar en Windows/Linux/Mac}.
%
%\section{Contribución de este trabajo}
%
%
%
\section{Organización del trabajo}
%
El presente trabajo se organiza de la siguiente forma. El Capítulo 1 introduce a el objetivo de el trabajo y lo enmarca dentro de una tecnología determinada además de presentar los objetivos generales que se persiguen. El Capítulo 2 expone algunas de las herramientas existentes que resuelven desde distintos enfoques la problemática que ataca este trabajo, nombrando entre ellas ORM, generadores de código y otros. El Capítulo 3 introduce formalmente la problemática que se esta atacando e introduce el concepto de Patrones de Diseño para terminar introduciendo la solución que se propone. En el Capítulo 4 es la especificación formal de la solución que se propone, para ello se divide el proyecto en dos módulos internos, un manejador de sentencias y un API para el acceso a motores de base de datos. El capitulo 5 documenta los aspectos importantes de el diseño sobre el que se construyo el proyecto, siguiendo para ello la división en dos módulos principales. El Capítulo 6 documenta los pormenores, ajustes y correcciones que se tuvieron que hacer durante la implementación de el proyecto y para terminar se comentan el modo en que se realizaron las pruebas sobre el código escrito. Para terminar con los capítulos se escribió una breve reseña sobre los resultados que se obtuvieron de el proyecto y el trabajo a futuro que se espera realizar.

Como Apéndice de la tesis se creo un manual de usuario que cubre los aspectos basicos de uso de la herramienta que se desarrollo y una descripción de una simple aplicación de ejemplo que muestra un uso practico de la herramienta.