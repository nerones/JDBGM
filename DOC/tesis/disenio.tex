\chapter{Diseño}\label{cap:disenio}

En este capitulo se documentara como se desarrollo el diseño de la arquitectura del proyecto, para ello se expondrá el modo en que trabaja \jd y además se mostrara la estructura de clases que se eligió para el sistema para que pueda cumplir con los requisitos expuestos en el Capitulo \ref{capitulo:especificacion}.





\section{Visión general}

Para diseñar \jj como ya se menciono se tomo como base a el patrón de desarrollo DAO que se explico en la sección \fullref{jdbgm:dao}, siguiendo la idea de este patrón \jj debe manejar todas las consultas echas a el motor por lo que la aplicación solo se deberá comunicar con \jj para acceder a el motor de base de datos, se puede observar esquemáticamente esta idea en la figura \figpage{fig:jdbgm:overview} en la que podemos observar que la idea es que la aplicación utilice el formato que estamos proponiendo para trabajar con las sentencias SQL, estas serán interpretadas por \jj y convertidas a una cadena de texto la cual es entendible por \jd y este se comunicara directamente con el DBMS y pondrá a disposición de \jj el resultado que dependiendo de la consulta puede ser un objeto del tipo \verb=ResultSet= o un tipo \verb=integer=. 

\begin{figure}
  \centering
    \includegraphics[width=0.85\textwidth]{figuras/jdbgm-overview.png}
  \caption{JDBGM dentro de una aplicación}
  \label{fig:jdbgm:overview}
\end{figure}

Así que \jj debe ser capaz de hacer dos tareas independientes pero relacionadas, en primer lugar debe proveer el almacenamiento de las sentencias de modo que puedan ser traducidas luego a el dialecto que corresponda y en segundo lugar proveer los métodos necesarios para comunicarse con el motor mediante \jd, podemos observar esquemáticamente la situación en la figura \figpage{fig:jdbgm:closerlook} que nos muestra la idea de independencia existente entre los dos módulos principales que se están exponiendo, el manejador de sentencias es totalmente independiente de la capa intermedia pues de lo que esta encargado es de proveer los métodos necesarios para ``armar las sentencias'' y traducirlas cuando sea requerido a el dialecto correspondiente, esta traducción lo que hace es convertir la sentencia almacenada a una cadena de texto la cual es entendible por \jd por lo que se podría obviar la capa intermedia que hace transparente su uso y usarlo directamente. En cambio la capa intermedia dependerá de el manejador de sentencias para poder proveer la independencia de dialectos que se quiere lograr y además este solo recibirá las sentencias compatibles con el formato propuesto por \jj por lo que a continuación se procederá a explicar la estructura propuesta para este manejador para que después se pueda explicar correctamente el funcionamiento de la capa intermedia.

\begin{figure}
  \centering
    \includegraphics[width=0.85\textwidth]{figuras/jdbgm-closerlook.png}
  \caption{Vista abstracta del funcionamiento de JDBGM}
  \label{fig:jdbgm:closerlook}
\end{figure}

\section{Manejador de sentencias}
Como ya se dijo el manejador de sentencias debe ser capaz de almacenar las sentencias de forma desglosada así que pasemos a ver que se quiere lograr. Como una primer solución podemos pensar que una sentencia como la siguiente ``\verb=nombre_comando parametro opcion1 parametro1 opcion2 parametro2='' que se podría corresponder con la siguiente consulta ``\verb|SELECT * FROM table WHERE table.id=1|'', salvando ciertas reglas de construcción que en este momento no vienen al caso, puede ser almacenado en una clase que se corresponda con el siguiente esquema:

\begin{lstlisting}[title=Pseudocódigo de la estructura de dato que contiene la sentencia]
class Sentencia{
	nombre_comando;
	parametro;
	set_opcion1(parametro1);
	set_opcion2(parametro2);
	devolver_sentencia();
}
\end{lstlisting}
Como se ve es una idea bastante sencilla en la que la clase identificara la sentencia y sus opciones correspondientes serán nombres de atributos pues en definitiva lo que nos interesa de estas opciones son los valores que toman o si están presentes o no en la sentencia que se esta armando. Como clase de POO también debe ofrecer métodos para almacenar los valores que tomaran las opciones y es aquí donde empiezan a jugar las reglas dispuestas en el dialecto genérico que fue especificado en el capitulo \ref{capitulo:especificacion}, puesto que las opciones ofrecidas por cada sentencia no pueden ser libremente usadas es necesario que estos métodos restrinjan el modo en que se pueden usar ya sea limitando las posibilidades de el/los métodos o bien usando excepciones para detener la ejecución del programa, una explicación mas detallada del manejo de excepciones se vera en las secciones siguientes, cuando alguna acción ilegal sobre las sentencias ocurra.

Con esto ya se tiene una idea genérica de las clases que se quiere representen a las sentencias y teniendo en cuenta que cada una de estas clases representa a una sentencia diferente con un comportamiento diferente pero con similitudes es necesario recalcar que estas diferentes clases deben presentar las mismas similitudes, por ejemplo supóngase que los objetos \verb|select| y \verb|create| representan las sentencias SQL del mismo nombre las cuales precisan que se les asigne el nombre de la tabla sobre la que se esta trabajando entonces lo correcto sera que ambos objetos tengan un método de igual nombre y comportamiento igual como por ejemplo \verb=select.set_table_name("name_1")= y \verb=create.set_table_name("name_2")=. Es muy importante tener en cuenta esto puesto que facilitara el aprendizaje del uso de la API del manejador de sentencias que se esta proponiendo y además hará el uso de la misma mucho mas natural, con respecto a SQL. Antes de empezar a hablar de lleno de la arquitectura propuesta para el manejador de sentencia es necesario nombrar al paquete \cc de el cual se tomaron algunas ideas.

\subsection{El paquete \cc}
Este paquete que puede ser encontrado en \href{http://sourceforge.net}{SourceForge} en la siguiente dirección \url{http://sourceforge.net/projects/crossdb/} intenta solucionar el mismo problema que el manejador de sentencias aquí presentado tal como se puede observar en la pagina del proyecto que se resume en la siguiente oración:

\begin{center}
``To provide cross database tools for manipulating all major databases without having to worry about each vendors specific implementation.''
\end{center} 

Esta librería  usa la misma idea de ir generando bajo demanda las sentencias por lo que se la estudio y se llego a la conclusión de que podía servir como base para el manejador que se quiere implementar en este proyecto. Algunas consideraciones antes de avanzar:
\begin{itemize}
\item El paquete se distribuye bajo Apache Software License 1.1 por lo que no hay inconvenientes en reusar el código escrito, siempre y cuando se respeten las condiciones impuestas. Además esta licencia es compatible con GPL.
\item La ultima actualización del proyecto data el 23-08-2005 (la ultima modificación registrada en el repositorio svn) por lo que aparentemente el proyecto quedo en un punto muerto y en una versión beta básica según se puede ver al revisar el código.
\item Carece de una buena documentación pero el código es bastante entendible y mas aun después de venir estudiando una solución similar a la propuesta por \cc


\end{itemize}
Se puede resumir la estructura usada por esta librería en el gráfico \fullref{fig:crossdb:base-idea} que nos muestra que por cada sentencia existe una Interfaz \verb=Statement= que define el comportamiento de la misma, luego para esta interfaz base existe una implementación por defecto \verb=DefaultStatement= que implementa las funciones que son comunes a toda implementación que se pueda realizar de dicha interfaz, recordando que al trabajar con dialectos estamos trabajando con variaciones de un lenguaje base, y por cada una de estas implementaciones por defecto existe una implementación especifica \verb=SpecificStatement= que contempla las particularidades de un motor en particular sobre dicha sentencia. En la misma figura podemos observar como se conforma dicha arquitectura para la sentencia \verb=SELECT= con la clases \verb=SelectQuery= siendo la interfaz base, \verb=DefaultSelectQuery= siendo la implementación por defecto de dicha interfaz y \verb=OracleSelectQuery= una implementación especifica para el dialecto usado por Oracle.


%\begin{figure}
%  \centering
%    \includegraphics[width=0.2\textwidth]{figuras/crossdb-base-idea.png}
%  \caption{Vista abstracta de la arquitectura de crossdb}
%  \label{fig:crossdb:base-idea}
%\end{figure}
\begin{figure}
  \centering
  \subfloat[Idea base]{\includegraphics[width=0.2\textwidth]{figuras/crossdb-base-idea.png}} \label{fig:subfig:crossdb:base-idea}
  \qquad 
  \subfloat[Ejemplo con Select]{\includegraphics[width=0.2\textwidth]{figuras/crossdb-base-idea-select.png}} \label{fig:subfig:crossdb:base-idea-select}
  \caption{Vista abstracta de la arquitectura de crossdb}
  \label{fig:crossdb:base-idea}
\end{figure}

Además de las clases a las que se hizo referencia \cc usa otras auxiliares, como \verb=Column= que contiene los datos necesarios para especificar una columna o \verb=WhereClause= que representa una clausula \verb=WHERE=, necesarias para poder almacenar adecuadamente los datos para las sentencias que se están armando. También se implementa la idea del patrón Factory pero de una manera muy básica. Terminado de presentar ligeramente este paquete sobre el cual se baso el diseño propuesto en este trabajo se pasara a exponer la arquitectura usada por el manejador de sentencias y su relación con las ideas tomadas de \cc.

\subsection{Diseño básico de el Manejador}
%Para la implementación de las especificaciones declaradas anteriormente nos encontramos con que existen algunas similitudes entre las diferentes clases definidas anteriormente, atendiendo a que cada clase representa a una de las sentencias SQL que se incluyeron en el proyecto y cada clase esta compuesta por:
Recordando lo expuesto en la sección anterior sobre las clases que representan las sentencias podemos resumir su contenido de manera muy genérica de la siguiente manera:

\begin{itemize}
\item Variables que almacenaran los datos necesarios para la construcción de los métodos, aunque también puede ser necesario el uso de clases auxiliares dependiendo de la complejidad de la clase.

\item Métodos para inicializar la clase y agregar (lo que comúnmente se dice \textit{setear}), es decir poblarla con los datos necesarios para su construcción.

\item Un método para armar la sentencia.

\end{itemize}

La estructura de cada una de estas clases puede ser implementada directamente desde las restricciones impuestas en la sección \fullref{seccion:especificacion:dialectos} pero siguiendo ciertos lineamientos que veremos a continuación.

En primer lugar se tiene que tener en cuenta la arquitectura general de el manejador para ello hay que observar lo siguiente: se puede hacer una distinción en como es que responde el motor de base de datos a las sentencias, o mas bien como responde JDBC, que es el "interlocutor" cuando procesa determinada sentencia SQL. Por un lado están aquellos que solo necesitan reportar la cantidad de filas afectadas por la sentencia después están aquellos que necesitan devolver información después de ejecutada la sentencia, estas ultimas sentencias son precisamente las que realizan consultas sobre la base de datos siendo las sentencias \verb=SELECT= las únicas que hacen esto. Por otro lado las sentencias \verb=UPDATE=, \verb=INSERT= y \verb=DELETE= solo precisan reportar la cantidad de filas que fueron afectadas por la consulta, en cambio las sentencias \verb=ALTER TABLE= y \verb=CREATE TABLE= que sirven para modificar las tablas (son parte del DDL de SQL) no afectan directamente a las filas de la misma pero por convención se tomo que \jd devuelva 0 como numero de columnas afectadas por lo que en este caso se las agrupara en el mismo conjunto. Entonces para que \jj pueda hacer distinción de estos dos tipos de consultas se utilizaron dos interfaces las cuales pueden ser tomadas como tipos genéricos, la \figpage{fig:crossdb-base} muestra estas interfaces y sus hijas.

\begin{figure}
  \centering
    \includegraphics[width=0.65\textwidth]{figuras/crossdb-base.png}
  \caption{Interfaces base para los tipos de sentencia}
  \label{fig:crossdb-base}
\end{figure}

De este modo se utilizan las interfaces \verb=UpdateStatement= y \verb=QueryStatement= como un tipo genérico para identificar las sentencias que no realizan consultas de aquellas que si, es decir si en la firma de cualquier método se declara algo similar a lo siguiente \verb=metodo_a(UpdateStatement statement)= el parámetro \verb=statement= podrá ser cualquier clase que sea heredera directa o indirectamente de la interfase \verb=UpdateStatement= y no podrá tomar ninguna heredera de la clase \verb=QueryStatement=, en este caso la herencia de la interfaz base sera indirecta como se aclarara a continuación y además cabe aclarar que este es el primer cambio que se agrego a la estructura que proponía \cc.

\begin{figure}
  \centering
    \includegraphics[width=0.65\textwidth]{figuras/crossdb-query.png}
  \caption{Diagrama de clases para la sentencia SELECT}
  \label{fig:query-base}
\end{figure}

En la \figpage{fig:query-base} tenemos una vista completa de como se debe componer la estructura de clases para el tipo base \verb=QueryStatement=, que es la mas simple pues solo tiene una clase hija, la única que sirve para hacer consultas sobre la base de datos la sentencia \verb=SELECT=. Como ya se dijo la primer interfase sirve para distinguir a nivel genérico el tipo de sentencia SQL que se esta tratando, la interfase hija directa de \verb=QueryStatement= si ya define un comportamiento especifico para las funciones de las sentencias \verb=SELECT=. La clase abstracta \verb=DefaultSelectQuery= brinda una implementación base para los métodos definidos en \verb=SelectQuery=, para comprender por que se debe hacer esto es necesario recordar que la clase que represente una sentencia contiene toda la información necesaria para generar una sentencia valida y esta información es la misma que se precisa para cualquier sentencia SQL de un dialecto en concreto (además ya se definió una sintaxis que es totalmente soportada) la diferencia esta en el modo que se escriben las sentencias, la sintaxis, por ello el único método que deberá ser especifico a un \dd será aquel que esta encargado de armar la sentencia. Después de la clase abstracta si por fin tenemos implementaciones especificas para cada uno de los motores, estas son la clase \verb=SpecificSelectQuery=de las que se hablaba en la \figpage{fig:crossdb:base-idea}, la idea es que de estas clases hayan tantas como motores estén soportados por el proyecto.

\begin{figure}
  \centering
    \includegraphics[width=\textwidth]{figuras/crossdb-update.png}
  \caption{Estructura de las otras sentencias}
  \label{fig:update}
\end{figure}

En la \figpage{fig:update} tenemos una descripción de como se deben estructurar los tipos de la interfaz base \verb=UpdateStatement=, esta es algo mas elaborada pero como antes la primer interfaz, funciona como tipo genérico, en las clases hijas de esta vemos algo parecido al caso de \verb=QueryStatement= salvo por la interfaz \verb=UpdateableQuery= que agrupa comportamiento común a \verb=Updatequery= e \verb=InsertQuery=, también se brinda un comportamiento predeterminado para esta mediante \verb=DefaultUpdateStatement= pero el cual al brindar una implementación base tiene que ser a la fuerza una clase abstracta\footnote{Una clase abstracta se puede ver como una interfaz que fuerza la implementación de parte de su comportamiento} así que las clases que definen el comportamiento especifico de \verb=UpdateQuery= e \verb=InsertQuery= son clases abstractas y no interfaces, pero el resultado es el mismo. Y finalmente para cada una de las interfaces que definen(o representan) a las sentencias tenemos una implementación por defecto en las clases cuyo nombre empieza por \verb=Default= de las cuales deberán heredar cada una de las implementaciones especificas, en la figura \ref{fig:update} no se las representa puesto que seria demasiado extenso.

Después de analizar el dialecto genérico que se definió en la sección \fullref{seccion:especificacion:dialectos} y de definir la estructura de las clases para el manejador se buscaron aquellos atributos de las clases (extraídos de las sentencias que representan) que por su complejidad ameritaban convertirse en una clase por si mismas, tal es el caso de una columna que en si es una entidad distinguible y lo suficientemente compleja como ejemplo podemos notar que una columna posee nombre, tipo de dato que almacena y muchas otras restricciones que pueden ser encontradas en el capitulo \ref{cap:disenio} en la sección que se refiere a la sentencia \verb=CREATE TABLE=. A continuación se listan y explican las clases auxiliares que se encontraron. 

%un análisis mas detallado de como se componen las interfaces finales y las clases que las implementan además de una vista a su implementación y las clases que sirven como componente de las principales.
\subsection{Clases Auxiliares} \label{seccion:disenio:clases-auxiliares}
Como ya se denoto para un adecuado y consistente funcionamiento de el manejador de sentencias es necesario crear algunas clases extras que brindan funcionalidades comunes a varias clases o bien funcionalidades extras no propias de dichas clases que ayudaran a formar las similitudes entre las diferentes clases que representan a las sentencias, a continuación un listado de estas:

\begin{itemize}
\item \verb=Column=
\item \verb=TableConstraint=
\item \verb=DataTypes=
\item \verb=Formater=
\item \verb=Functions= (no decidido por completo)
\item \verb=Join=
\item \verb=SpecificSQLFactory=
\item \verb=SQLFactory=
\item \verb=SQLFormat, SQLDateTimeFormat, SQLTimeFormat=(estas no son usadas o movidas a Formatter)
\item \verb=WhereClause, WhereCondition, WhereFrame=
\end{itemize}
A continuación una descripción de ellas

\subsubsection{La clase Column}
Representa una columna de una tabla para ello posee atributos tales como nombre de columna, banderas que indican si es clave foranea y todos los demás atributos que sirven para definir la columna en una sentencia \verb=CREATE TABLE=. Entre sus métodos no se incluye ninguno que sirva para convertir la columna en una cadena  de texto que sirva para definirla en una sentencia SQL pues a pesar de que la sintaxis de la definición de columna no varia demasiado, salvo por los tipos de datos, si varia el uso sobre ella pues la sentencia \verb=ALTER TABLE= también puede definir columnas en su sintaxis pero con ciertas restricciones como se ve en la sección \ref{sec:altertable} y para evitar confusiones cada clase (clase que represente una sentencia) que haga uso de un objeto columna deberá implementar las restricciones sobre la construcción de la sentencia ignorando los atributos que no use.

Además de esto la columna también posee un atributo para almacenar un valor para la columna de modo que la clase no solo sirva para definir una columna si no también como contenedor del valor, del tipo y del nombre  de la columna para usarlo luego con otras sentencias que no necesiten definir columnas si no ingresarles datos como es el caso de \verb=INSERT=. Haciendo esto se evita crear otra clase que solo sirva de contenedor para el valor de una columna y por lo tanto hay menos clases para recordar. Además se deja abierta la posibilidad de establecer a que tipo de datos pertenece el valor que se esta ingresando para poder manejar el modo en que este valor es convertido a \verb=String=, para aclarar esto supóngase que se quiere ingresar un valor booleano a una columna y como los constructores de esta clase aceptan para el parámetro que establece el valor para la columna un objeto de la clase \verb=Object= se le puede pasar cualquier objeto por lo que intuitivamente se le podría pasar una cadena \verb|columnValue ="TRUE"| a menos que se indique el tipo de columna a la clase la clase puede inferir que se quiere enviar una cadena de texto y convertirla a  por ejemplo \verb|.. SET boolean_column = 'TRUE'| que puede llevar a un error cuando se intente enviar la sentencia a el motor, en cambio si el tipo de dato es establecido a boolean la clase lo convertirá en un \verb=1= o \verb=0= según corresponda.

\subsubsection{Las restricciones de tabla en TableConstraint}
Esta clase representa lo que en una sentencia \verb=CREATE TABLE= vendría a ser una restricción de tabla, las cuales pueden ser \verb=PRIMARY KEY, FOREIGN KEY o UNIQUE= estas restricciones a su vez pueden hacerse sobre una (clave simple) columna o bien sobre varias (clave compuesta). La razón por la que se eligió crear una clase para representar las restricciones de tabla es que de no existir se complicaba mucho la "traducción" a SQL de la clase que representa a \verb=CREATE TABLE=, esta clase representa un medio mas sencillo para la traducción de la restricción, como contra parte se puede observar que la sintaxis se vuelve un poco mas compleja pero aun así es mayor el beneficio pues se hace mas sencilla la traducción a cadena de caracteres. 

\subsubsection{La clase DataTypes}
Esta es una clase abstracta que servirá para mapear los tipos de datos a los correspondientes a los de un motor especifico, esto se logra mediante un método que toma como entrada los tipos de datos definidos por \jd y los mapea a los tipos de datos encontrados en el capitulo anterior.


\subsubsection{La interfaz Formatter}
La Interfaz \verb=Formatter= sirve para definir el modo en que algunos tipos de datos han de ser convertidos a su equivalente como cadena de caracteres, se puede decir que define un formateador. Se provee una implementación por defecto de esta interfaz en \verb=DefaultFormatter= la cual puede llegar a servir sin modificaciones para el motor sobre el que se este trabajando, aun así esta implementación por defecto obligara a que se cree una clase que herede de la misma puesto que se tratara de una clase abstracta y como tal no puede ser instanciada directamente. La clase que herede de dicha implementación puede no definir nada y ser creada solamente para poder instanciar la implementación base a través de esta pero se exige su implementación por si llegase a ser necesario sobrescribir (\textit{override}) algunos de los métodos ya implementados para manejar adecuadamente algún tipo de dato según lo requiera el motor de bases de datos.

\subsubsection{Functions}
\verb=Functions= (no decidido por completo)

\subsubsection{Join}
\verb=Join=
\verb=Join= Básicamente representa las condiciones de \verb=JOIN= para las sentencias \verb=SELECT=.

\subsubsection{SQLFactory y SpecificSQLFactory}
\verb=SpecificSQLFactory=
\verb=SQLFactory=
Clases constructoras de Objetos (\textit{Factories})
\subsubsection{Parseando los datos de forma adecuada}
\verb=SQLFormat, SQLDateTimeFormat, SQLTimeFormat=

\subsubsection{La restricción WHERE como WhereClause}
Como la clausula \verb=WHERE= no es mas que una lista de condiciones en la que intervienen los mismos operadores lógicos, comparativos y específicos de SQL como por ejemplo el operador \verb=IN= se decidió crear una clase que lo contenga, en resumen no hay implementación especifica pues es la misma para todos, además el uso de una misma clase para generar las restricciones en las distintas sentencias facilita y ''unifica'' el uso de las mismas.

En definitiva esta clase debe proveer un amplio abanico de funciones para facilitar el ingreso de los diferentes tipos de condiciones que intervienen en la clausula \verb=WHERE=. Entre las sentencias que utilizan esta clase tenemos a: \verb=SELECT=, \verb=UPDATE= y \verb=DELETE= estas deberán proveer un método que devuelva una referencia a un objeto \verb=WhereClause= que sera miembro de la misma e igualmente llamado, el método. Este método debe ser especificado en las diferentes interfaces que especifiquen el comportamiento de las sentencias que recién se nombraron. 

\subsection{Manejo de errores}

\subsection{Diseño de cada una de las sentencias}
Una vez que se presento el esqueleto del proyecto ya se puede empezar a ver las particularidades de cada una de las ramas finales que en este caso son las interfaces, aunque es bueno aclarar que estas particularidades son las que precisamente delinearon a la estructura que se expuso anteriormente, por lo que a continuación se explicara en mas detalle la relación de las interfaces que definen a las sentencias y las clases auxiliares como así también detalles que se creen importantes recordando que las interfaces quedan casi completamente definidas por la especificación que se dio en la sección \ref{seccion:especificacion:dialectos}.

\subsubsection{La interfaz para CREATE TABLE}
La sentencia \verb=CREATE TABLE= representada en la interfaz \verb=CreateTableQuery= básicamente sirve para definir columnas y restricciones de tabla, aunque en las columnas también es posible definir algunas de las restricciones pero estas están limitadas ya que solo se pueden definir sobre dicha columna. En el dialecto genérico que se definió anteriormente se encontraron compatibilidades con las definiciones de restricciones de columna pero al analizar la estructura necesaria para una implementación de la misma a nivel clases se termino por excluirlas por que complicaban la conversión del objeto a \verb=String= al ser necesario estar comprobando si una columna pertenece a una restricción de columna o a una restricción de tabla (lo que involucraba iteraciones extras) , además restringir el tipo de restricciones a las de tabla únicamente evidencio la  necesidad de una clase que almacene dicha restricción con la consiguiente simplificación de la interfaz principal.


\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{figuras/jdbgm-dc-createtable.png}
  \caption{Diagrama de clases para la interfaz de CreateTableQuery}
  \label{fig:dc-createtable}
\end{figure}


La clase \verb=TableConstraint= representa a las restricciones de tabla la cual necesita referencias (punteros a los objetos) de las columnas que componen la tabla que se esta por crear y además es posible definir los otros atributos que tienen las restricciones de tabla que se pueden ver en la sección  \fullref{especificacion:dialectos:create}. Lo que no se contemplo en esta interfaz y tampoco es posible definir mediante la misma es el control de la integridad de la sentencia en el sentido de que si es correcta o no pues de hacerlo aumentaría el procesamiento necesario para poder convertir esta sentencia a cadena de caracteres complicando y agregando trabajo extra a la capa de software que accede a el motor, trabajo que en definitiva el terminara realizando de nuevo lo que en definitiva se resumiría en una redundancia innecesaria. Lo único que cambiara al obviar estas comprobaciones es quien terminara por reportar el error por lo que no se realizan este tipo de comprobaciones.

Por ultimo hay que señalar el uso de la clase \verb=Column= para almacenar la definición de las columnas, que además después sera reutilizada como contenedora de valores. Esta clase originalmente contenía las definiciones de las restricciones de columnas pero desde la creación de la clase \verb=TableConstraint= estas fueron eliminadas con la única excepción de la restricción combinada de clave primaria con columna  auto-incrementada del tipo entera.

\subsubsection{La interfaz para UPDATE}
La sentencia \verb=UPDATE= al igual que la sentencia \verb=INSERT= precisa que se le indiquen las columnas sobre las cuales se quiere trabajar, pudiendo ser todas o solo algunas de las columnas, es por ello que se decidió crear una interfaz intermedia que defina este comportamiento para ambas sentencias, dicha interfaz es \verb=UpdateableQuery= la cual precisamente define los métodos necesarios para poder establecer cuales serán las columnas sobre las que se trabajara. Una vista completa de como se disponen las clases necesarias para esta sentencia se puede ver en la figura \ref{fig:dc-updatequery} en ella podemos apreciar que esta interfaz común hace uso de la clase \verb=Column= para almacenar los nombres y valores para las columnas además de los tipos de datos que se precisan para esa columna, aunque como quedo definida la interfaz se deja abierta la posibilidad de que \jj decida a que tipo de dato pertenece el valor que se le acaba de establecer, esto se hace mediante las implementaciones de la interfaz \verb=Formatter= que decide como se debe interpretar el valor de la columna. Y por ultimo antes de entrar directamente a la interfaz especifica para esta sentencia vemos que existe una implementación base para que el comportamiento no solo quede definido sino que también implementado. 

\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{figuras/jdbgm-dc-update.png}
  \caption{Diagrama de clases para la interfaz de UpdateQuery}
  \label{fig:dc-updatequery}
\end{figure}

Poco le queda por definir a la interfaz \verb=UpdateQuery=, como se puede apreciar en la sección \ref{especificacion:dialectos:update} falta por definir la restricción \verb=WHERE= lo cual se hace mediante la clase auxiliar \verb=WhereClause=, por lo que esta interfaz debe poder devolver un objeto de dicha clase para crear la restricción, este objeto debe ser atributo de la clase que implemente esta interfaz para que luego la clase pueda interactuar con ella y obtener la restricción. 
%El uso de las clases auxiliares y de la interfaz \verb=UpdateableQuery= simplifico mucho a 

\subsubsection{La interfaz para INSERT}

La sentencia \verb=INSERT= como ya se menciono hace uso de la interfaz común \verb=UpdateableQuery= para definir su comportamiento base, luego sera la interfaz \verb=InsertQuery= la que defina el comportamiento especifico para dicha sentencia como se puede observar en la \figpage{fig:dc-insertquery}. En esta interfaz se define el comportamiento especificado en la sección \pageref{especificacion:dialectos:insert}, no hay mas para aclarar con respecto al diseño salvo que esta sentencia puede ser armada a partir de tres fuentes distintas para las cuales existen sendas funciones, como el uso de estas fuentes debe ser excluyentes una de la otra, es decir solo se puede usar una fuente a la vez, se decidió que la interfaz optara como fuente para la sentencia a aquella que haya sido establecida en ultima instancia mediante la llamada a el método correspondiente.

\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{figuras/jdbgm-dc-insert.png}
  \caption{Diagrama de clases para la interfaz de InsertQuery}
  \label{fig:dc-insertquery}
\end{figure}

\subsubsection{La interfaz para ALTER TABLE}
La sentencia \verb=ALTER TABLE= expresada en la interfaz \verb=AlterTAbleQuery= presenta una estructura bastante simple como se puede ver en la \figpage{fig:dc-altertabletquery} únicamente hace uso de la clase auxiliar \verb=Column= y nada mas tal como se puede apreciar en la sección \ref{especificacion:dialectos:altertable} del capitulo de especificación. Tampoco hay mucho para aclarar debido a la simplicidad de la especificación para dicha sentencia, en parte debido al pobre soporte que tiene sobre esta sentencia el motor \ss y además por que no esta contemplado dentro de lo que serian los métodos CRUD pero como \cc presentaba un soporte para esta se la termino por agregar.
\begin{figure}
  \centering
    \includegraphics[width=0.5\textwidth]{figuras/jdbgm-dc-altertable.png}
  \caption{Diagrama de clases para la interfaz de AlterTableQuery}
  \label{fig:dc-altertabletquery}
\end{figure}

\subsubsection{La interfaz para DELETE}
La sentencia \verb=DEELETE= definida en la interfaz \verb=DeleteQuery= es otra de las que es bastante sencilla

\subsubsection{La interfaz para SELECT}

\subsection{Implementación del patrón Factory}










\section{Capa de acceso a el motor - JDBC}
y otro

\subsection{Como funciona JDBC}
Java ya nos provee JDBC para acceder a las bases de datos, pero al hacer uso de el es necesario especificar con que motor se esta trabajando, para ejemplificar ello veamos el típico código que debemos escribir para conectarnos a una base de datos.

\begin{lstlisting}[title=Porción de codigo java para la conexión a una base de datos]
class conectDB(){
...

Class.forName("com.mysql.jdbc.Driver");
	Connection conexion = DriverManager.getConnection(
		"jdbc:mysql://localhost/AsistenciaAlumnos", "tester",
		"tester");
	Statement st = (Statement) conexion.createStatement();

...
}
\end{lstlisting}

En esta porción de código lo que se hace inicialmente es instanciar el driver, es decir crear el objeto driver, luego el método estático \verb=getConnection= de 	\verb=DriverManager= nos devuelve un objeto que representa la conexión al motor con el que se esta trabajando. Este objeto del tipo \verb=Connection= nos provee métodos para generar objetos \verb=Statement= que nos permite hacer consultas a la base de datos mediante las funciones que dispone. Una descripción mucho mas extensa de JDBC puede ser encontrada en la documentación disponible en la web de Oracle\citep{java:jdbc}.
Para nuestro proyecto necesitamos ocultar y simplificar el API de JDBC
\subsection{Manejo de errores y excepciones}

\subsection{Que se devuelve como resultado}
