\chapter{Implementación}
Después de decidir las características de las que dispondrá \jj es necesario analizar como se implementaran estas. Por el lado de \cc tenemos que las interfaces que definen el comportamiento de las clases que contendrán a las sentencias SQL comparten muchas cosas por lo que hay que analizar adecuadamente las herencias y definición de interfaces. Elegir adecuadamente la estructura del proyecto puede hacer la diferencia entre una librería\footnote{como lo defino al final!!!!!!} mantenible y ampliable contra una pila de código difícil de entender. Así que como en el capitulo anterior analizaremos \jj por secciones  primero la sección que se encarga de manejar la conexión con la base de datos y después la que se encarga de abstraer el uso de SQL.






\section{Implementación de el envoltorio de \jj}

A few words




\section{Implementación de \cc}



\subsection{Clases extras}\label{sec:extras}


\subsection{Implementación de AlterTableQuery}
Todas las interfaces menos \verb=SelectQuery= descienden de \verb=UpdateStatement=, esta es una interfaz que no define comportamiento alguno solo sirve para categorizar las interfaces hijas en cuanto a pertenencia o no a el grupo de las sentencias que no devuelven datos de la base de datos si no sobre la base de datos, su implementación a continuación:

\begin{lstlisting}[title=interfaz UpdateStatement]
package com.crossdb.sql;

public interface UpdateStatement {

}
\end{lstlisting}

La interfaz \verb=AlterTable= si ya define el comportamiento para las clases hijas de la misma que servirán para armar las sentencias \verb=ALTER TABLE=, al ser la sintaxis soportada muy limitada la interfaz es bastante simple. Se definen los métodos necesarios para poblar la sentencia de datos y despúes armarla. La función que devuelve la sentencia propiamente dicha sera la típica \verb=toString()= pero redefinida para que devuelva adecuadamente la sentencia SQL adecuada. 

\begin{lstlisting}[title=interfaz AlterTableQuery]
package com.crossdb.sql;

public interface AlterTableQuery extends UpdateStatement{
	
	void setTable(String table);
	
	void addColumn(Column c);
	
	void newTableName(String table);
}
\end{lstlisting}
Hay algunas cosas a tener presentes por ejemplo el método \verb=addColumn(Column)= utiliza la clase \verb=Column= que representa una columna tal como se definió en \ref{sec:extras}. Además las funciones \verb=addColumn(Column)= y \verb=newTableName(String)= que respectivamente sirven para añadir columnas a la tabla y renombrar la misma son mutuamente excluyentes en el sentido que una sentencia solo puede realizar unas de las acciones previamente nombradas a la vez, por lo que si en un mismo objeto se llamase a las dos funciones solo tendrá efecto la ultima en ser llamada.\\

En cuanto a la implementación base \verb=DefaultALterTableQuery= hay poco que comentar pues únicamente agrega los atributos necesarios para implementar las funciones definidas en \verb=AlterTableQuery=, las hijas de esta clase ya serán especificas para un \dd concreto, en nuestra implementación contamos con tres a saber:
\begin{itemize}
\item \verb=MySQLAlterTableQuery=
\item \verb=SQLiteAlterTableQuery=
\item \verb=PostgreSQLAlterTableQuery=
\end{itemize}
Cuya única misión es implementar, o re-implementar si se quiere, el método \verb=toString()= que entregara la sentencia SQL en forma de cadena de texto dentro de un objeto String.




\subsection{Implementación de DeleteQuery}
La sintaxis soportada para \verb=DeleteQuery= es muy limitada por lo que es posible observar casi todo el código de la Interfaz principal para estas sentencias:

\begin{lstlisting}[title=código interfaz QueryStatement]
package com.crossdb.sql;

public interface DeleteQuery extends UpdateStatement{

	void setTable(String table);

	void addWhereCondition(String x, int comparison, String y);

	void addWhereCondition(String x, int comparison, int y);

	void addWhereCondition(String x, int comparison, java.util.Date y);

	void addWhereCondition(String and_or, String x, int comparison, String y);

	void addWhereCondition(String and_or, String x, int comparison, int y);

	void addWhereCondition(String and_or, String x, int comparison,
			java.util.Date y);

	void addWhereCondition(WhereCondition cond);

	void addWhereClause(WhereClause wc);

	void addWhereString(String x, int comparison, String y);

	void addWhereString(String and_or, String x, int comparison, String y);

	void addWhereNotNull(String col);

	void addWhereNotNull(String and_or, String col);

	void addWhereIsNull(String col);

	void addWhereIsNull(String and_or, String col);
	new

}
\end{lstlisting}



\subsection{Implementación de UpdateQuery e InsertQuery}




\subsection{Implementación de CreateTableQuery}




\subsection{Implementación de selectQuery}

Esta interfaz es la única que desciende de la interfaz padre \verb=QueryStatement= la cual podemos ver en su totalidad ya que se trata de una interfaz muy simple:

\begin{lstlisting}[title=código interfaz QueryStatement]
package com.crossdb.sql;

public interface QueryStatement {

}
\end{lstlisting}

Como ya se dijo no necesita definir ningún comportamiento, salvo por la pertenencia a un grupo que es en este caso la de el tipo de sentencias que ejecutan consultas sobre la base de datos. La interfaz hija si ya define comportamientos específicos que servirán para poblar de datos y armar las sentencias \verb=SELECT= las métodos mas importantes de su implementación la podemos ver a continuación:

\begin{lstlisting}[title=código interfaz UpdateStatement]
package com.crossdb.sql;

import java.util.Date;
import com.crossdb.sql.optimization.OptimizationHint;

public interface SelectQuery extends QueryStatement {

	void addColumn(String column);

	void addFunctionColumn(String function, String column);

	void sumColumn(String column);

	void countColumn(String column);

	void countColumn(String table, String column);

	void averageColumn(String column);

	void averageColumn(String table, String column);

	void minColumn(String column);

	void minColumn(String table, String column);

	void maxColumn(String column);

	void maxColumn(String table, String column);

	void addTable(String table);

	void addTable(int joinType, String table);

	void addTable(int join_type, String table, WhereCondition cond);

	void addTable(Join join);

	void addWhereCondition(String x, int comparison, String y);

	void addWhereCondition(String x, int comparison, int y);

	void addWhereCondition(String x, int comparison, long y);

	void addWhereCondition(String x, int comparison, Date y);

	void addWhereCondition(String and_or, String x, int comparison, String y);

	void addWhereCondition(String and_or, String x, int comparison, int y);

	void addWhereCondition(String and_or, String x, int comparison, long y);

	void addWhereCondition(String and_or, String x, int comparison, Date y);

	void addWhereString(String x, int comparison, String y);

	void addWhereString(String and_or, String x, int comparison, String y);

	void addWhereCondition(WhereCondition cond);

	void addWhereClause(IWhereClause wc);

	void addOrderBy(String order_by);

	void addGroupBy(String group_by);

	void union(SelectQuery sq);

	void setDistinct(boolean distinct);

	void setLimit(int offset, int rowCount);

}
\end{lstlisting}
