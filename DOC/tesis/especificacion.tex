\chapter{Especificación}
\label{capitulo:especificacion}
En este capitulo estableceremos los requisitos necesarios para cumplir con las necesidades que presentamos anteriormente, para ello estableceremos que medidas debemos tener en cuenta a la hora de establecer el API que nos permitirá comunicarnos con el motor de base de datos y además que se requiere para que el código escrito sea independiente del motor en particular que se este por utilizar.
%trabajando con mysql 5.1 reference manual\\
%trabajando con PostgreSQL 8.4 reference manual\\
%sqlite con el de la pagina la version 3\\
%
%
\section{Contexto}
%
El proyecto como ya se comento se desarrollara sobre el lenguaje Java e inicialmente se dará soporte para tres motores de base de datos, las versiones usadas de cada una de ellas para el desarrollo del proyecto son las siguientes:
\begin{enumerate}
	\item Java SE 6 o versión superior.
	\item PostgreSQL 8.4
	\item MySQL 5.1
	\item Sqlite 3
\end{enumerate}
%
En este capitulo se pretenden declarar los requerimientos generales del proyecto para cumplir con su objetivo y el por que de los mismos. Básicamente hay dos tópicos diferentes a tratar: primero se definirá como se ocultara el acceso a la base de datos en otras palabras definir que funciones debe proveer la interfaz que ocultara el uso de JDBC; en segundo lugar esta definir como se trataran las sentencias SQL para que no sean ``dialecto dependientes".
%
\section{Ocultando el acceso a el motor}
Cuando se habla de ocultar el acceso a el motor se esta haciendo referencia a que la API proveída por este proyecto debe en primer termino ocultar el uso de JDBC, en el sentido de que no se hace uso explicito de los métodos que este ofrece, en segundo lugar se refiere a que los métodos proveídos por la API aquí desarrollada no deben ser ``motor dependiente'' para evitar que el código escrito con ella también lo sea. Para manejar el acceso al motor de base de datos \jj debe proveer las siguientes funcionalidades mínimas que a su vez puede que se desglosen en mas de una función (o método):
%
\begin{enumerate}
%
\item Crear una conexión con el motor: es decir se debe encargar de obtener una conexión al motor y ponerla a disponibilidad de los métodos definidos, verificando que cuando se la necesite esta siga estando ``viva''.
%
\item Cerrar la conexión con el motor: poder cerrar la conexión con el motor para liberar recursos de la misma, una conexión no usada sin cerrar es un desperdicio de recursos.
%
\item Enviar sentencias SQL al motor: el modo de interactuar con el motor es mediante el envío de sentencias SQL, este punto se lo discutirá mas ampliamente en la sección siguiente.
%
\item Poder enviar transacciones: una transacción consiste en un conjunto de sentencias que deben ejecutarse en conjunto, una vez finalizadas se guardan los cambios (commit) o se rechazan (rollback) si sucediere algún error en cualquiera de las sentencias que se pretenden ejecutar como un conjunto.
%
\item Manejar los errores que se puedan producir: se pueden dar errores en la sintaxis de las sentencias SQL como así también errores en la lógica de las sentencias que se formaron, como por ejemplo equivocarse en el nombre de una tabla o referirse a una columna inexistente, además pueden existir otros tipos de errores que no están directamente relacionados con el \dd, por ejemplo que la conexión de red necesaria para comunicarse con un motor que se encuentra en un servidor externo falle. Estos errores deben ser correctamente atrapados para que el programador evite que el programa que esta desarrollando simplemente se cuelgue.
%
\item Devolver resultados de las consultas, por ejemplo para una consulta del tipo \verb=SELECT= es necesario devolver el conjunto de datos que resultaron de la consulta, para las otras sentencias DML como \verb=INSERT= puede resultar necesario conocer la cantidad de columnas que fueron afectadas.
%
\item Manejar la creación de los objetos de modo que se instancien desde la clase adecuada dependiendo de el motor que se esta por utilizar. En primer instancia esto puede parecer algo trivial pero es en realidad importante por que libera al programador de la necesidad de decidir que clase debe instanciar y hace a el código independiente de una implementación particular de las interfaces definidas.
\end{enumerate}
%
%
\section{Eliminando dialectos}
\label{seccion:especificacion:dialectos}
En el capitulo anterior se comento que parte del desafío de este proyecto consiste en lidiar con los diferentes  dialectos utilizados por cada motor en particular, por lo que a continuación se analizara como es que se pretende sortear esta dificultad.

\jd provee la clase \verb=Statement=\footnote{Posteriormente se explicara como es que se trabaja con JDBC, por ahora interesa solo lo expuesto.} la cual posee los métodos \verb=executeUpdate= y \verb=executeQuery= los cuales permiten enviar sentencias SQL al motor de base de datos. El envío de estas sentencia se hace mediante cadenas de texto por lo que se nos presenta el problema de que estas cadenas ``estáticas'' dependen, según cuan complejas sean las sentencias, de el motor en particular que se este usando. Es por ello que en este proyecto se opto por generar las sentencias sobre demanda, es decir se pretende que las sentencias se almacenen desglosadas de modo que su sintaxis quede expuesta y pueda luego ser volcada en una cadena de texto cuando sean requeridas por el programador. El almacenar de este modo las sentencias no asegura tampoco la independencia de los dialectos usados pero permite manejar el modo en que las sentencias serán convertidas en cadenas de textos, entonces si se define un nuevo dialecto que sea compatible con los dialectos usados por los otros motores y ajustando la estructura de datos que se va a utilizar para las sentencias a este dialecto se puede, mediante las reglas adecuadas, "traducir" la sentencia a su dialecto correspondiente. 

Definir un nuevo dialecto puede parecer algo engorroso, pero en realidad este nuevo dialecto estará basado en los dialectos usados por los motores a los que se le esta dando soporte y además solo se trabajara con un subconjunto de las sentencias definidos en estos dialectos pues no es objetivo del proyecto brindar un total soporte sobre SQL si no que se pretende cubrir un subconjunto de estas que permitan realizar las operaciones usualmente conocidas como CRUD\footnote{Aunque a veces se cambian el significado de algunas de las siglas, usualmente la definición dada es la mas usada.} que viene del ingles ``\textit{Create, Read, Update and Delete}'' que puede traducirse en el uso de las sentencias SQL \verb=INSERT, SELECT, UPDATE= y \verb=DELETE=.

Las necesidades del proyecto quedarían satisfechas con el soporte para las sentencias listadas en el párrafo anterior pero como esta parte del proyecto se basara en una librería pre-existente que también da soporte para las sentencias \verb=CREATE TABLE= y \verb=ALTER TABLE= estas también serán incluidas como parte del proyecto. Un punto interesante de aclarar es que no hay que confundir la sentencia \verb=CREATE TABLE= con la operación \textit{create} a la que hace referencia el acrónimo CRUD pues este se refiere a crear un nuevo registro en el sistema de persistencia de datos que se este usando, llevándolo al ámbito de los motores de base de datos relacionales se refiere a crear una fila en una tabla, mientras que \verb=CREATE TABLE= sirve para crear tablas, las filas en las tablas se insertan mediante \verb=INSERT=, visto esto y como no es parte del objetivo planteado para el proyecto el soporte para estas dos sentencias sera básico, dejando las puertas abiertas para que en futuras versiones el trabajo pueda ser refinado fácilmente. Por lo que las siguientes sentencias serán las reconocidas por \jj:
%
\begin{itemize}
\item \verb=CREATE TABLE= - Permite crear tablas. 
\item \verb=ALTER TABLE= - Modifica la estructura de una tablas.
\item \verb=UPDATE= - Modifica las filas de una tabla.
\item \verb=INSERT= - Inserta nuevas filas a una tabla.
\item \verb=DELETE= - Elimina filas de una tabla.
\item \verb=SELECT= - Realiza consulta sobre las tablas.
\end{itemize}
%
%
Las sentencias listadas anteriormente cubren las necesidades que se pueden presentar en la lógica de negocio del proyecto sobre el cual se este trabajando, el uso de mas extensivo de SQL se da a la hora de la administración de la base de datos trabajo que usualmente es realizado por la persona que cumpla el rol de DBA (\textit{Data Base Administrator}) el cual usa una interfaz diferente, propia a veces de el motor mismo, para trabajar directamente sobre el.

La estructura de datos que se quiere manejar, la cual quedara expresada en forma de una clase, aparte de contener los datos que hacen a la sentencia debe brindar métodos para convertir la sentencia en una cadena de texto, asignarles valores a los atributos y definir el comportamiento especifico que pueda tener la sentencia. Así podemos hacer un resumen de las características que se desea cumplan estas clases:
\begin{itemize}
%
	\item Deben poder devolver una cadena de caracteres (\textit{String}) que represente una sentencia SQL valida para el dialecto deseado.
	\item La sintaxis proveída para el manejo de las clases debe ser consistente entre todas ellas de modo que el aprendizaje de esta no presente mayor dificultad y debe ser lo suficientemente ``expresiva'' como para poder entender lo que se esta haciendo sin tener que recurrir necesariamente a la documentación, lo que tampoco quita que la documentación deba ser dejada de lado. 
	\item Deben contemplar de manera básica que no se realicen acciones no permitidas con las sentencias, es decir respetar la sintaxis de los dialectos, aspecto que también ah de tenerse en cuenta cuando se este definiendo el dialecto genérico para el proyecto. El manejo de estos errores debe ser mediante el uso de excepciones usando las clases hijas de \verb=Exception= en Java.
	\item Deben contemplar todas las opciones disponibles para las sentencias que se están por incluir definidas en el dialecto genérico.
	\item Deben proveer los métodos necesarios para poblar de datos las clases.
%
\end{itemize}
%
Una vez definido el subconjunto de sentencias con las que se trabajaran es necesario definir el dialecto genérico sobre el cual se apoyara este proyecto, por lo que para cada una de las sentencias se definirá un comportamiento común, pero para que esto sea posible se deberán restringir los dialectos soportados al que menos posibilidades presente pues las diferencias entre los dialectos usados por los motores se da generalmente por que se agregan funcionalidades a las definidas en el estándar  SQL y raramente se da el caso en que la diferencia se de por la falta de implementación de lo definido en el estándar. Como parte del análisis de las diferencias entre los dialectos es importante analizar también los tipos de datos que se usan en cada \dd. También para ellos se debe encontrar un factor común, mas que nada por la inclusión de la sentencias \verb=CREATE TABLE= y \verb=ALTER TABLE= que precisan que se definan tipos de datos, por lo que a continuación se dedicara una sección entera a analizar los tipos de datos usados por cada motor.
%
%\begin{lstlisting}[title=Pseudocódigo de la estructura de dato que contiene la sentencia]
%class Sentencia{
%	nombre_comando;
%	parametro;
%	opcion1(parametro1);
%	opcion2(parametro2);
%	devolver_sentencia();
%}
%\end{lstlisting}
%
\subsection{Tipos de datos y sus diferencias}
\label{subsection:datatypes}
Al analizar los tipos de datos usados en los diferentes motores, quizá la diferencia mas notoria se da en el modo en que \s maneja estos tipos. La mayoría de los motores de datos manejan un tipo de datos estático, en el que el contenedor del dato (la columna) define el tipo de dato que este podrá almacenar, o sea el tipo de dato declarado en la definición de la columna. En cambio en \s no existen los tipos de datos como tal, si no que se definen clases de almacenamiento\cite{sqlite:datatypes} (\textit{storage clases}) que son mas genéricas que los tipos de datos usualmente definidos, por ejemplo la clase de almacenamiento \verb=INTEGER= puede almacenar los 6 diferentes tipos de datos enteros que define \m , que en definitiva en lo único que difieren es en el espacio que ocupan para ser almacenados, por ejemplo \verb=SMALLINT= ocupa menos bits para ser representado que el tipo \verb=INTEGER=.

En \s el tipo de dato de un valor esta asociado a el dato en si y no a su contenedor, pero aun así existe compatibilidad con los otros motores en el sentido de que \s puede interpretar adecuadamente sentencias SQL validas que usen los clásicos tipos de datos estáticos. Para brindar esta compatibilidad se define el concepto de afinidad de tipo para las columnas que viene a ser el tipo de dato recomendado para los datos almacenados en esa columna, así existe una serie de reglas para definir la afinidad de la columna en base a el nombre del tipo de dato declarado para esa columna, pudiendo ser este nombre cualquiera. Aun así la afinidad de la columna \textbf{recomienda} un tipo de dato no lo exige para esa columna, por lo que en \s una columna puede almacenar cualquiera de los tipos de datos definidos (storage class para \s). Observado esto podemos decir que al ser \s tan flexible los tipos de datos que se usaran estarán definidos en base a \m y \p.
 
\jj debe proveer una interfaz única en la que se establezcan los tipos de datos disponibles para usar, estos tipos de datos deben ser elegidos en base a las compatibilidades entre los diferentes motores que soporta para lograr un uso genérico sobre cualquiera de los motores. En principio se podrían elegir todos los tipos de datos definidos en los motores, uniendo a aquellos que sean equivalentes en un solo tipo y dejando que después \jj se encargue de mapear los datos a los soportados por un motor en concreto, recordando que algunos de los datos declarados no son directamente soportados por todos los \dd. Pero esto podría acarrear confusiones pues el tipo de dato entero mas chico (el que ocupa menos espacio en disco para representarse) en \m\cite{mysql:datatypes} es \verb=TINYINT= que ocupa solo 1 byte, en cambio en \p\cite{postgre:datatypes} el mas chico es \verb=SMALLINT= que ocupa 2 bytes entonces en el caso de que en los tipos de datos especificados para \jj se encuentren estos dos no habría problemas al usarlos pues si se llegara a especificar una columna con tipo de dato \verb=TINYINT= mientras se trabaja sobre una base de datos con \p no habría mas que mapear internamente el tipo de dato a \verb=SMALLINT= que al ser mas grande tranquilamente lo puede contener, pero en esta situación el programador podría no enterarse de que en realidad la columna que el esta usando ocupa 2 bytes por dato lo que en casos en que  la capacidad  de almacenamiento sea un tema sensible podría llevar a serias confusiones, entonces lo mejor es que en la especificación de \jj solo se incluyan los tipos que no lleven a este tipo de confusiones. A continuación se analizan los tipos de datos y sus congruencias, empezando por los datos numéricos del tipo entero mediante un cuadro comparativo en los que los tipos puestos en la misma linea son congruentes entre si, salvo que se indique lo contrario:
%        
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline \s      & \m        & \p \\ 
\hline         & TINYINT   &  \\ 
               & SMALLINT  & SMALLINT \\ 
       INTEGER & MEDIUMINT &  \\
               & INT       & INTEGER \\
               & BIGINT    & BIGINT \\  
\hline 
\end{tabular} 
\end{center}
\caption{Comparación de los tipos de datos enteros}
\end{table}
%
Como podemos ver la clase de almacenamiento \verb=INTEGER= de \s es capaz de contener todos los tipos de datos declarados en los otros dos motores, en \m se definen mas tipos de datos enteros que  difieren únicamente en el espacio que utiliza para almacenarse en disco, el mas chico usa  solo 1 Byte para almacenarse, mientras que el mas grande usa 8 Bytes. En \s el dato es almacenado en disco con la menor cantidad posible de Bytes pero tan pronto como es cargado en memoria es convertido a un entero de 8 bytes con signo\footnote{Cuando al representarse un numero se usa el signo ($\pm$) se achica el rango de numero que se puede representar}. Lo que nos  interesa a nosotros es elegir un subconjunto de estos tipos que sean aplicables a los tres motores, en este caso es \p el que define menos tipos de datos, teniendo en cuenta que \s presenta un tipo de dato que envuelve a todos los demás, por lo que tomaremos esos tipos como los elegidos para \jj
%
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline \s   & \m               & \p \\  
\hline      & FLOAT            &  \\ 
       REAL & REAL             & REAL \\
            & DOUBLE PRECISION & DOUBLE PRECISION \\
\hline 
\end{tabular} 
\end{center}
\caption{Comparación de los tipos de datos reales aproximados}
\end{table}
%
En el caso de los tipos de números reales tenemos básicamente dos clases de tipos, los que guardan los datos de forma exacta y otros no exactos que se guardan en el formato punto flotante. Para el caso de los tipos de datos con punto flotante se tomaran los tipos definidos para \p como los elegidos para \jj, el tipo \verb=FLOAT= definido en \m es similar a \verb=REAL=, y nuevamente el tipo \verb=REAL= de \s es capaz de contener los otros tipos. 
%
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline \s & \m & \p \\  
\hline  & NUMERIC & NUMERIC \\
  & DECIMAL & DECIMAL \\
NUMERIC  & DATETIME &  \\
  & TIMESTAMP & TIMESTAMP \\
  & DATE & DATE \\
  & TIME & TIME \\  
\hline 
\end{tabular} 
\end{center}
\caption{Comparación de los tipos de datos reales exactos y fechas}
\end{table}
%
Para analizar el caso de los tipos de datos reales con almacenamiento exacto, deberemos analizar los tipos de datos de fecha y hora, pues aunque parezca un poco confuso \s no tiene un tipo de dato especifico para estos tipos, pero si posee una afinidad de columnas para ellos que se denomina, \verb=NUMERIC=, este afinidad lo que hace es decidir cual es el mejor modo de almacenar el dato, pudiendo ser cualquier de las clases \verb=NULL, INTEGER, REAL, TEXT= y \verb=BLOB=. Para los tipos \verb=NUMERIC= Y \verb=DECIMAL= que son para almacenamiento exacto de números reales no tenemos una clase especifica, pero lo que si podemos hacer es asignarle el tipo (afinidad de columna) \verb=NUMERIC= que se encargara de que el motor guarde el dato en el formato que le parezca mas adecuado. Para los datos del tipo fecha y hora tenemos bastante similitud  en \m y \p salvo que en \m esta \verb=DATETIME= que en lo unico que difiere de \verb=TIMESTAMP= es en el rango de fechas que soporta. En \s no tenemos tipos de datos para fecha y hora, pero se pueden guardar las fechas como cadenas de texto o numero, por lo que si se le da la afinidad de columna \verb=NUMERIC= el motor resolver cual es el mejor tipo de datos para almacenar la facha u hora según el formato que estemos utilizando.   
%
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline \s & \m & \p \\ 
\hline  & CHAR(n) & CHAR(n) \\  
    & VARCHAR(n) & VARCHAR(n) \\ 
  TEXT   & TINYTEXT &  \\  
    & TEXT & TEXT \\
    & MEDIUMTEXT &  \\  
    & LONGTEXT &  \\  
\hline 
\end{tabular} 
\end{center}
\caption{Comparación de los tipos de datos cadenas de texto}
\end{table}
%
Para el caso de los tipos de datos cadenas de texto tenemos como siempre \s con una clase de almacenamiento bastante genérica que cubre todos los tipos de datos definidos en los demás motores. La diferencia que encontramos con los otros dos motores es que el tipo \verb=TEXT= que en \m tiene 4 variantes que varían en el limite de almacenamiento, siendo el ultimo sin limite (\verb=LONGTEXT=) en cambio en \p existe solo \verb=TEXT= y que es para almacenamiento de texto sin limite, así que como antes tomaremos los tipos de datos que define \p como los elegidos para \cc. 
%
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline \s & \m & \p \\ 
\hline  & BINARY &  \\  
 & VARBINARY &  \\ 
 BLOB & TINYBLOB & bytea \\ 
 & BLOB &  \\ 
 & MEDIUMBLOB &  \\
& LONGBLOB &  \\ 
\hline 
\end{tabular} 
\end{center}
\caption{Comparación de los tipos de datos binarios}
\end{table}
%
En el caso de los tipos de datos binarios tenemos.
Faltan los tipos monetarios, booleanos
%
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline \s & \m & \p \\ 
\hline 1 o 0 & 1 o 0 & BOOLEAN \\  
\hline NUMERIC & NUMERIC & MONETARY \\  
&  &  \\  
\hline 
\end{tabular} 
\end{center}
\caption{Comparación de tipos de datos varios}
\end{table}
%
\subsection{Funciones}
\label{especificacion:funciones} 
Las funciones que presentan los diferentes motores son variadas, en la documentación de  \p se puede leer\citep{postgre:functions} la siguiente aclaración:
%
\begin{quotation}
\textit{If you are concerned about portability then note that most of the functions and operators described in this chapter, with the exception of the most trivial arithmetic and comparison operators and some explicitly marked functions, are not specified by the SQL standard. Some of this extended functionality is present in other SQL database management systems, and in many cases this functionality is compatible and consistent between the various implementations.}
\end{quotation}
%
Que en resumen explica que la mayoría de las funciones ofrecidas por \p con excepción de algunas pocas no forman parte de ninguno de los estándares SQL por lo que no hay que esperar compatibilidad entre los diferentes motores aunque existen algunas funciones comunes que se pueden encontrar entre los diferentes motores. Así que a continuación se buscaran funciones similares entre los diferentes motores a los que se les esta dando soporte en este proyecto, para lo cual empezaremos con una tabla comparativa en la que las funciones equivalentes de la misma linea tiene la palabra igual para denotar tal situación:

\begin{table}[h]
\begin{center}
{
\fontfamily{pcr}
\selectfont
\begin{tabular}{|c|c|c|}
\hline 
\s & \m & \p \\  
\hline 
abs(X) & igual & igual \\ 
\hline 
changes() & ROW\_COUNT() & - \\ 
\hline 
coalesce(X,Y,...) & igual & igual \\ 
\hline 
glob(X,Y) & - & - \\ 
\hline 
ifnull(X,Y) & igual & mediante coalesce(x,y) \\ 
\hline 
hex(X) & igual & - \\ 
\hline 
length(X) & LENGTH() & char\_length(string) \\ 
\hline 
like(X,Y,Z) & x LIKE y [ESCAPE z] & igual mysql \\ 
\hline 
lower(X) & igual & igual \\ 
\hline 
ltrim(X) & igual) & igual \\ 
\hline 
max(X,Y,...) & - & - \\ 
\hline 
min(X,Y,...) & - & - \\ 
\hline 
nullif(X,Y) & igual & igual \\ 
\hline 
quote(X) & igual & quote\_literal(string text) \\ 
\hline 
random()integer & RAND()float & random() float \\ 
\hline 
randomblob(N) & - & - \\ 
\hline 
replace(X,Y,Z) & igual & igual \\ 
\hline 
round(X), round(X,Y) & igual & igual \\ 
\hline 
rtrim(X) & igual & igual \\ 
\hline 
substr(X,Y,Z), substr(X,Y) & igual & igual \\ 
\hline
trim(X), trim(X,Y) & igual & igual \\ 
\hline
upper(X) & igual & igual \\ 
\hline
\end{tabular}
}
\end{center}
\caption{Comparación de las funciones core de \s}
\label{tabla:core_functions}
\end{table}  
%
En la tabla \ref{tabla:core_functions} están listadas las funciones que son parte de las funciones básicas\citep{sqlite:functions} o \textit{core functions} de \s que como se puede ver no son muchas, igual se obviaron algunas funciones especificas de \s aunque las aquí presentadas son una gran parte de las mismas, lo que se pretende mostrar con esta tabla es la equivalencia de estas funciones con las que presentan los otros motores para lo cual se estudio la documentación proveída por \p\cite{postgre:functions} y por \m\citep{mysql:functions} y se encontraron las equivalencias mostradas.

Tal como fue señalado existe cierta universalidad entre las funciones que ofrecen los motores como por ejemplo ocurre con la función \verb=abs()= que se usa de igual manera en todos los motores y diferencias como con la función \verb=ifnull()= que en \p no existe pero se tiene un resultado igual con la función \verb=coalesce()=, además \s aclara en su documentación que \verb=ifnull(x,y)= es equivalente a \verb=coalesce(x,y)=, otras diferencias también se pueden ver en funciones que no tienen equivalente en los otros motores como ocurre en el caso de la función \verb=randomblob(N)= de \s. De todos modos es posible definir nuevas funciones en cualquiera de los tres motores con lo que se puede llegar a una total compatibilidad pero esa no es la intención de este proyecto, lo que se pretende es buscar las compatibilidades existentes entre los motores por lo que \jj tendrá disponible un conjunto de funciones que son reconocidas por los tres motores de manera predeterminada.

De las funciones ofrecidas por este proyecto solo se ofrecerá el nombre de la función quedando a cargo del usuario la correcta utilización de las mismas teniendo en cuenta que a pesar de tener los mismos nombres la implementación de una función en un motor puede ser mas permisiva que en otro en cuanto a los parámetros aceptados y las valores que devuelven, así que de existir un error este sera reportado cuando se intente usar la sentencia que se formo haciendo uso de cualquiera de estas funciones. \s tiene algunas funciones mas disponibles por defecto que están documentadas en dos capítulos aparte por lo que a continuación veamos dos tablas que muestran las equivalencias de las mismas en los otros motores.

\begin{table}[h]
\begin{center}
{
\fontfamily{pcr}
\selectfont
\begin{tabular}{|c|c|c|}
\hline 
\s & \m & \p \\ 
\hline 
avg(X) & igual & igual \\ 
\hline 
count(X) & igual & igual \\ 
\hline 
count(*) & igual & igual \\ 
\hline 
group\_concat & group\_concat & array\_to\_string \\ 
(X[,Y]) & ( X [separator Y]) & (array\_agg(X), Y) \\
\hline 
sum(), total() & igual & igual \\ 
\hline 
max() & igual & igual \\ 
\hline 
min() & igual & igual \\ 
\hline 
\end{tabular} 
}
\end{center}
\caption{Comparación de las funciones agregadas de \s}
\end{table}  

Entre las funciones agregadas de \s encontramos que casi todas son compatibles excepto por la función \verb=group_concat= que presenta una sintaxis algo diferente pero funciona igual en \m y se puede obtener el mismo resultado en \p mediante el uso de dos funciones distintas, la otra función que no existe en los demás motores es \verb=total()= que es similar a \verb=sum()= pero  trabaja de manera diferente con los valores \verb=null= y además a diferencia de \verb=sum= devuelve siempre un \verb=float= como resultado. Cabe aclarar que \verb=max()= y \verb=min()= aparecen también en el \textit{core} de \s pero estas son diferentes pues toman distintos parámetros y se comportan de manera diferente.

\begin{table}[h]
\begin{center}
{
\fontfamily{pcr}
\selectfont
\begin{tabular}{|c|c|c|}
\hline 
\s & \m & \p \\ 
\hline 
date() & igual con now() & current\_date or date() \\ 
\hline 
datetime() & timestamp() , now() & to\_timestamp, current\_timestamp \\ 
\hline 
time() & time() con now() & "time"() or now()::time \\ 
\hline 
julianday() & - & - \\ 
\hline 
strftime() & - & varios \\ 
\hline 
\end{tabular} 
}
\end{center}
\caption{Comparación de las funciones Fecha y Hora de \s}
\label{table:functions:dates}
\end{table}

La tabla \ref{table:functions:dates} muestra las funciones que tiene \s para el manejo de fechas y horas y sus equivalentes de existir en los otros dos motores, las funciones que define \s tienden a estar sobrecargadas (o admiten valores por defecto para los parámetros como en PHP) por ejemplo la función \verb=date()= de usársela sin ningún parámetro devuelve la fecha (DATE) actual en el formato \verb='YYYY-MM-DD'= en cambio si se le pasa una cadena de texto equivalente a un \verb=TIMESTAMP= la misma función devuelve la porción de la fecha de la cadena de texto, para lograr esto en \m y \p se usan dos funciones para obtener la misma funcionalidad por ejemplo si en \s se quiere obtener la fecha (DATE) actual se debe usar \verb=date(now())= y \verb=date(D)= funcionaria como en \s donde \verb=D= es una fecha completa (TIMESTAMP). Para \verb=juliandays()= y \verb=strftime()= se pueden obtener resultados parecidos mediante el uso de más de una función o realizando algunos cálculos, por lo que no existe una función equivalente para las mismas a menos que se la defina o se usen  más de una para obtener el mismo resultado.

Como se dijo previamente el uso de las funciones puede llegar a comprometer la portabilidad y salvo por aquellas mas comunes se pueden obtener resultados diferentes ante las mismas entradas por lo que \jj debe ofrecer las funciones que tengan su equivalente en los otros motores y no debe chequear sintaxis pues esto ya lo hará el propio motor, el realizar esta comprobación seria una redundancia y un aumento de procesamiento con su correspondiente sobrecarga totalmente evitable. Por lo que el soporte para funciones se limitara a ofrecer una lista de funciones permitidas pero dejando la puerta abierta a el uso de otras a riesgo propio del programador.


\subsection{Sentencias SQL}
En las siguientes secciones se pasa a analizar por separado cada una de las sentencias que se están por incluir en nuestro dialecto genérico, para ello se compararan las implementaciones que se hicieron sobre cada uno de los motores sobre los que se da soporte.

\subsubsection{Especificación de CREATE TABLE} 
\label{especificacion:dialectos:create}
Esta sentencia es usada para crear tablas en una base de datos relacional, un resumen de su sintaxis como se la define en el estándar SQL es la siguiente:
\begin{Verbatim}
  CREATE TABLE <table name> (
  { <column name> [ <column type> ][ PRYMARY KEY ][ REFERENCES <foreign table> ] }...
  )
  [ PRIMARY KEY <indexed columns> ]
  [ FOREIGN KEY <columns and referenced table> ]
\end{Verbatim}
Se obviaron las definiciones de algunas de las opciones de\verb= CREATE TABLE= puesto que escapan al alcance del proyecto el cual esta limitado por los DBMS a los que tiene que soportar además hay que tener en cuenta algunas salvedades, como que si se especifica una columna como\verb= PRIMARY KEY= dentro de la definición de la columna no se puede especificar la clausula\verb= PRIMARY KEY= fuera de los paréntesis que encierran a las definiciones de las columnas. Mas específicamente podemos empezar con \s el cual, sin restarle importancia, es el que menos características implementa debido a su ``pequeñez'' por lo cual pasamos a estudiar\verb= CREATE TABLE= tal como la entiende \s\cite{sqlite:sql}\footnote{para ver la sintaxis usada ir a QQQQQQQQ} y comparando las diferencias con \m\citep{mysql:sql} y \p\citep{postgre:sql}

\begin{Verbatim}[frame=leftline, framesep=3mm]
  CREATE [ TEMP | TEMPORARY ] TABLE <database name> <dot> <table name> 
  [ IF NOT EXISTS ] <table contents source>

  <table contents source> ::=
    <left paren> <table element> [ { <comma> <table element> }... ] <right paren>
  | AS <select stmt>
\end{Verbatim}

Los parámetros\verb= TEMPORARY= y\verb= TEMP= se usan indistintamente para crear una tabla temporaria en \s, lo cual es soportados por los 3 DBMS con la salvedad que en \m solo se acepta la palabra reservada\verb= TEMPORARY=. El parámetro\verb= IF NOT EXISTS= indica que de existir una tabla del mismo nombre la sentencia \verb= CREATE TABLE= no tiene efecto sobre la base de datos, este parámetro no es soportado por \p por lo que sera omitido. Por ultimo hay que tener en cuenta que al ser \s un motor ``serverless'' siempre se esta trabajando o sobre la base de dato principal o sobre una temporaria por lo que este para el parámetro\verb= <database name>= solo acepta\verb= "main"= ó\verb= "temp"= de modo que en un principio el nombre de la base de dato no se tomara en cuenta y cualquier tabla que se cree sera en la base de dato actual.  La restricción \verb=AS <select stmt>= funciona de manera similar para los tres motores de base de datos por lo que también sera incluida, en lo único que varían es en como son reconocidos los tipos de datos y además que debido a \s los nombres de las columnas agregadas deben ser los mismo que los de la sentencia \verb=SELECT=, por ultimo vale aclarar que \verb=<select stmt>= debe ser una sentencia \verb=SELECT= valida y correspondiente a el mismo motor.

\begin{Verbatim}
  <table element> ::=
    <column definition>
  | <table constraint definition>

  <column definition> ::=
  <column name> [ <data type> | <domain name> ]
  [ DEFAULT <default option> ]
  [ <column constraint definition>... ]
  [ COLLATE <colation name> ]

  <default option>::=
    <signed number>
  | <literal value>
  | <left paren> <expr> <left paren>
  
  <column constraint definition> ::=
  [ CONSTRAINT <name> ] <column constraint>

  <column constraint> ::=
    NOT NULL <conflict cause>
  | UNIQUE <conflict cause>
  | PRIMARY KEY [ ASC | DESC ] <conflict cause> [ AUTOINCREMENT ]
  | <references specification>
  | CHECK <left paren> <expr> <right paren>
\end{Verbatim}

La siguiente sección a estudiar es la definición de columnas y restricciones de columna que se diferencian de las restricciones de tabla en que las primeras se definen junta a la definición de columna y solo se pueden hacer sobre una única columna, en cambio las restricciones de tabla se hacen después de las definiciones de columnas y estas pueden referirse a un grupo de columnas.\\

Como primer diferencia veremos las tipos de datos tienen diferentes nombres y significados, pero esto ya fue tratado en la sección \fullref{subsection:datatypes}. La clausula\verb= DEFAULT= en este caso esta limitada por \m que solo acepta valores constantes, es decir no se podria usar funciones como \verb= NOW()= con la excepción de que se puede poner\verb= CURRENT_TIMESTAMP= como\verb= DEFAULT= para una columna del tipo\verb= TIMESTAMP=.\\

El parámetro\verb= COLLATE= también presenta diferencias, pero es en este caso es \p el que limita ya que no acepta\verb= COLLATE= en la definición de columna por lo que no sera adoptada en la especificación de \jj. En \p se puede especificar el ``collate'' a usar sobre todas las tablas en la creación de la base de datos. \verb= UNIQUE= y \verb= PRIMARY KEY= como restricción de columna no acepta ningún modificador en \m, por lo tanto se obviara el modificador\verb= <conflict cause>= de \s y otros que acepta \p. El parametro \verb= NOT NULL= tampoco acepta ningún modificador en \m, su contra parte el parámetro\verb= NULL= puede ser omitido ya que de no agregarse se toma por defecto que la columna puede aceptar valores nulos. Por ultimo hay que señalar que \m si bien implementa\verb= CHEK <expre>= este no es reconocido en la definición de columna.\\

En \s y \p a las restricciones de columna se les puede especificar un nombre con \verb=CONSTRAINT <name>= pero esto no es soportado en \m una ultima diferencia la podemos ver en el parámetro\verb= AUTOINCREMENT= (\verb=AUTO_INCREMENT= en \m) que solo se puede especificar cuando una columna es\verb= PK= y del tipo \verb= INTEGER=, en \m se puede hacer incluso sobre columnas que no sean \verb=PK=, en \p este parámetro no existe, al menos no en la version  sobre la que se esta trabajando. Aun así es posible sortear este problema en \p es posible usar la palabra clave \verb=SERIAL= la cual es un atajo para crear una secuencia y asignársela a la columna, en este caso se usara para emular el funcionamiento de la clausula anterior y con \m lo único que hace falta es limitar esta clausula como lo hace \s.   

\begin{Verbatim}
  <table constraint definition> ::=
  [ CONSTRAINT <name> ] <table constraint>

  <table constraint> ::=
    [ UNIQUE | PRIMARY KEY ] <left paren> <unique column list> <right paren> <conflict cause>
  | <referential constraint definition>
  | CHECK <left paren> <expr> <right paren>

  <unique column list> ::= <column name list>

  <referential constraint definition> ::=
  FOREIGN KEY <left paren> <referencing columns> <right paren>
  <references specification>
\end{Verbatim}

De las restricciones de tabla la única a la que no se le podrá especificar un nombre de restricción con \verb=CONSTRAINT <name>= es la restricción \verb=CHECK (expr)=. Los parámetros \verb=UNIQUE= y \verb=PRIMARY KEY= que se especifican como restricción de tabla solo comparten en común entre la especificación de los 3 DBMS que encierran entre paréntesis a las columnas que se indican con dicha restricción. Resta por analizar la especificación de clave foránea (\verb=FK=):    

\begin{Verbatim}
  <references specification> ::=
  REFERENCES <referenced table and columns>
  [ MATCH { FULL | PARTIAL | SIMPLE } ] [ <referential triggered action> ]
  [ <constraint characteristics> ]

  <referenced table and columns> ::=
  <table name> [ <left paren> <reference column list> <right paren> ]

  <reference column list> ::= <column name list>

  <referential triggered action> ::=
    <update rule> [ <delete rule> ]
  | <delete rule> [ <update rule> ]

  <update rule> ::= ON UPDATE <referential action>

  <delete rule> ::= ON DELETE <referential action>

  <referential action> ::=
    CASCADE
  | SET NULL
  | SET DEFAULT
  | RESTRICT
  | NO ACTION

   <constraint characteristics> ::=
  [ NOT ] DEFERRABLE [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
\end{Verbatim}
Los parámetros \verb=MATCH { FULL | PARTIAL | SIMPLE }= son reconocidos en los 3 DBMS, pero en \s no tienen ningún efecto, es decir que estos se pueden especificar pero siempre se tendrá que la \verb=FK= se procesara con \verb=MATCH SIMPLE=, con lo que de momento sera parte de la especificación pero hay que tener siempre en cuenta que \s lo procesara de manera diferente. Por ultimo quedan dos diferencias, la primera es que la opción \verb=SET DEFAULT= de \verb=<referential action>= no es soportada por \m; segundo que \verb=<constraint characteristics>= no es soportada por \m.\\

%------------------------TODO-----------------------------------
%revisar lo de SET DEFAULT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


%----------------------------Especificación de CREATE TABLE------------

Así que finalmente tenemos las siguiente sintaxis de \verb=CREATE TABLE= para el proyecto\\

\begin{Verbatim}[frame=single, label=sintaxis para CREATE TABLE]
  CREATE [ TEMPORARY ] TABLE <database name> <dot> <table name> 
  <table contents source>

  <table contents source> ::=
    <left paren> <table element> [ { <comma> <table element> }... ] <right paren>
  | AS <select stmt>
  
  <table element> ::=
    <column definition>
  | <table constraint definition>

  <column definition> ::=
  <column name> [ <data type> | <domain name> ]
  [ DEFAULT <constant> ]
  [ <column constraint>... ]
  
  <column constraint> ::=
    NOT NULL
  | UNIQUE
  | PRIMARY KEY [AUTO_INCREMENT]
  | <references specification>

  <table constraint definition> ::=
  [ CONSTRAINT <name> ] <table constraint>

  <table constraint> ::=
    [ UNIQUE | PRIMARY KEY ] <left paren> <unique column list> <right paren>
  | <referential constraint definition>
  | CHECK <left paren> <expr> <right paren>

  <unique column list> ::= <column name list>

  <referential constraint definition> ::=
  FOREIGN KEY <left paren> <referencing columns> <right paren>
  <references specification>
  
  <references specification> ::=
  REFERENCES <referenced table and columns>
  [ MATCH { FULL | PARTIAL | SIMPLE } ] [ <referential triggered action> ]

  <referenced table and columns> ::=
  <table name> [ <left paren> <reference column list> <right paren> ]

  <reference column list> ::= <column name list>

  <referential triggered action> ::=
    <update rule> [ <delete rule> ]
  | <delete rule> [ <update rule> ]

  <update rule> ::= ON UPDATE <referential action>

  <delete rule> ::= ON DELETE <referential action>

  <referential action> ::=
    CASCADE
  | SET NULL
  | RESTRICT
  | NO ACTION


\end{Verbatim}




\subsubsection{Especificación de UPDATE} 
\label{especificacion:dialectos:update}
Esta sentencia es usada para actualizar los datos de una tabla, es decir para modificar valores existentes de filas. El análisis de la siguiente sintaxis corresponde a como es entendida la sentencia \verb=UPDATE= por \s\cite{sqlite:sql} 

\begin{Verbatim}
  <update statement> ::=
  UPDATE [ OR <or option> ] <target table> 
  SET <set clause list>
  [ WHERE <search condition> ]
  
  <or option> ::=
    ROLLBACK
  | ABORT
  | REPLACE
  | FAIL
  | IGNORE
\end{Verbatim}

En este punto encontramos la primer diferencia con los demas DBMS, el elemento \verb=<or option>= que nos permite especificar que acción tomar si no es posible realizar la acción de \verb=UPDATE= sobre la tabla, es un añadido de \s que no esta presente en las especificaciones de los otros dos DBMS y tampoco aparece en la especificación de SQL.

\begin{Verbatim}
  <target table> ::=
  [ <database name> <dot> ] <table name>
  [ INDEXED BY <index name> ]
  [ NOT INDEXED ]
  
  <set clause list> ::= <set clause> [ { <comma> <set clause> }... ]

  <set clause> ::=
  <column name> <equals operator> <expr>
  
  -----Solo disponible si se habilito durante la compilación---------
  
  [ ORDER BY <ordering-term> ]
  [ LIMIT <expr> ]

\end{Verbatim}
Las elementos \verb=[ INDEXED BY <index name> ]= y \verb=[ NOT INDEXED ]= no son reconocidos por \m y \p por lo que serán ignorados en la especificación de el proyecto. Lo demás es de idéntica sintaxis salvo por las opciones \verb=ORDER BY= y \verb=LIMIT= que solo están disponibles en \s si durante la compilación de el motor se habilito la opción \verb=SQLITE_ENABLE_UPDATE_DELETE_LIMIT= la cual por defecto esta desactivada y además \p no las reconoce por lo que quedan descartadas. La especificación final de \jj queda como sigue.

\begin{Verbatim}[frame=single, label=sintaxis para UPDATE]
  <update statement> ::=
  UPDATE <target table> 
  SET <set clause list>
  [ WHERE <search condition> ]
  
  <target table> ::=
  [ <database name> <dot> ] <table name>
  
  <set clause list> ::= <set clause> [ { <comma> <set clause> }... ]

  <set clause> ::=
  <column name> <equals operator> <expr>    
\end{Verbatim}




\subsubsection{Especificación de INSERT} 
\label{especificacion:dialectos:insert}
La sintaxis que analizo a continuación corresponde a la sentencia \verb=INSERT= que sirve para insertar filas nuevas en una tabla dada, felizmente la sentencia de \verb=INSERT= entendida por \s solo difiere en dos aspecto de las otras, primero es que esta presenta el elemento \verb=<or option>= que no es soportado por los otros DBMS, segundo el elemento \verb=REPLACE= que tampoco es reconocido por los demas motores. Además es bueno aclarar que \s esta restringiendo las capacidades de los otros motores, como por ejemplo en \m existe el elemento \verb=ON DUPLICATE KEY UPDATE= el cual sirve para resolver conflictos cuando una insercción en una tabla provoca que alguna columna que deba ser única (\verb=PK= ó \verb=UNIQUE=) presente un valor duplicado. Así que sin mas la siguiente es la sintaxis elegida y compatible con los tres motores:

\begin{Verbatim}[frame=single, label=sintaxis para INSERT]
  <insert statement> ::=
  INSERT INTO <insertion target> <insert columns and source>

  <insertion target> ::= [ <database name> <dot> ] <table name>

  <insert columns and source> ::=
    <from subquery>
  | <from constructor>
  | DEFAULT VALUES

  <from subquery> ::=
  [ <left paren> <insert column list> <right paren> ]
  <query expression>
  
  <from constructor> ::=
  [ <left paren> <insert column list> <right paren> ]
  VALUES <left paren> <exp> [ { <comma> <exp> }... ] <right paren>

  <insert column list> ::= <column name list>
\end{Verbatim}




\subsubsection{Especificación de ALTER TABLE} 
\label{especificacion:dialectos:altertable}
\verb=ALTER TABLE= sirve en SQL para alterar la estructura de las tablas, en este caso nos encontramos con que \s esta limitando a los demás motores pues la sintaxis que soporta esta muy limitada, las únicas acciones que soportan son renombrar las tablas y agregar nuevas columnas a una tabla. Por lo que la sintaxis final elegida es la misma que soporta \s:\\

%\begin{Verbatim}
%  <alter table statement> ::= 
%  ALTER TABLE [ <database name><dot> ] <table name> <alter table action>
%  
%  <alter table action> ::=
%    RENAME TO <new table name>
%  | ADD [ COLUMN ] <column def>
%\end{Verbatim}
\begin{Verbatim}[frame=single, label=sintaxis para ALTER TABLE]
<alter table statement> ::= 
  ALTER TABLE [ <database name><dot> ] <table name> <alter table action>
  
  <alter table action> ::=
    RENAME TO <new table name>
  | ADD [ COLUMN ] <column def>
\end{Verbatim}

Además de estas limitaciones hay algunas mas, al agregar nuevas columnas la definición de estas puede tomar cualquiera de las opciones disponibles en la definición de \verb=CREATE TABLE= excepto por las siguientes:

\begin{enumerate}

\item La columna no puede ser clave primaria o \verb=UNIQUE=.

\item La columna no puede tener como valor por defecto \verb=CURRENT_TIME=, \verb=CURRENT_DATE=, \verb=CURRENT_TIMESTAMP=, o una expresión entre paréntesis.

\item Si la columna no puede tener valor nulo se ha de especificar un valor por defecto diferente de \verb=NULL=

\item If foreign key constraints are enabled and a column with a REFERENCES clause is added, the column must have a default value of NULL.

\end{enumerate}



\subsubsection{Especificación de DELETE} 
\label{especificacion:dialectos:delete}
La sintaxis de \verb=DELETE= entendida por \s es la siguiente
\begin{Verbatim}
  <delete statement> ::=
  DELETE FROM <target table> [ WHERE <search condition> ]

  <target table> ::=
  [ <data base name><dot> ] <table name>
  [ INDEXED BY <index name> ]
  [ NOT INDEXED ]
\end{Verbatim}
En ella podemos encontrar una diferencia con las demás motores de bases de datos, elementos que serán omitidos. Esta diferencia es que no es posible usar los elementos \verb=INDEXED BY <index name>= y \verb=NOT INDEXED= en \p y \m, además cabe aclarar que no se están agregando elementos que si son soportados por los otros motores. Así que finalmente nos queda la siguiente sintaxis:


\begin{Verbatim}[frame=single, label=sintaxis para DELETE]
  <delete statement> ::=
  DELETE FROM <target table> [ WHERE <search condition> ]
  
  <target table> ::=
  [ <data base name><dot> ] <table name>
  
\end{Verbatim}




\subsubsection{Especificación de SELECT} 
\label{especificacion:dialectos:select}
Esta sentencia es quizá la mas compleja a analizar debido a la cantidad de posibilidades que presenta así sin mas analizamos a continuación \verb=SELECT= tal como es conocido por \s:

\begin{Verbatim}
  <query specification> ::=
  <select core> [ { <compound operator> <select core> }... ]
  [ ORDER BY <ordering term> [ { <comma> <ordering term> }... ]
  [ LIMIT <expr> [ { OFFSET | <comma> } <expr> ] ]  
\end{Verbatim}

Hasta este punto la sintaxis usada es compatible con los otros dos motores, por lo que sera aceptada tal cual, así que se siguen buscando diferencias:

\begin{Verbatim}
  <select core> ::=
  SELECT [ DISTINCT | ALL ] <result column> [ { <comma><result column> }... ] 
  [ FROM <join source> ]
  [ WHERE <exp> ]
  [ GROUP BY <group list> ]
  
  <group list> ::=
  <ordering term> [ { <comma><ordering term> }... ]
  [ HAVING <expr> ]
  
  <result column> ::=
    <asterisk>
  | <table name><dot><asterisk>
  | <expr> [ [ AS ] <column alias> ]
  
  <join source> ::=
  <single source> [ { <join op> <single source> <join constraint> }... ]
  
  <single source> ::=
    [ <data base name> ] <table name> [ [ AS ] <table alias> ] [ <index option> ]
  | <left paren> <select stmt> <right paren> [ [ AS ] <table alias> ]
  | <left paren> <join source> <right paren>
  
  <index option> ::=
    INDEXED BY <index name> 
  | NOT INDEXED
  %not in postgre
  <join op> ::=
    <comma>
  | [ NATURAL ] [ LEFT [OUTER] | INNER | CROSS ] JOIN
  
  <join constraint> ::=
    [ ON <expr> ]
  | USING <left paren> <comma><column name> <right paren>
  
  <ordering term> ::=
  <expr> [ COLLATE <collation name> ] [ ASC | DESC ]
  %no COLLATE en mysql no ASC DESC en postgre
  <compound operator> ::=
    UNION [ ALL ]
  | INTERSECT 
  | EXCEPT
  %solo union para Mysql
\end{Verbatim}
Son pocas las incompatibilidades que podemos encontrar, pero existen, la primera incompatibilidad es que el elemento \verb=<index option>= no es aceptado por \p; segundo en el elemento \verb=<ordering item>= nos encontramos con que \m no soporta establecer la opcion \verb=COLLATE= y \p no acepta la anterior ni los elementos \verb=ASC, DESC=; por ultimo \m solo acepta \verb=UNION [ ALL ]= para el elemento \verb=<compound operator>=. Así que nuestra sintaxis final quedaría de la siguiente manera:  

\begin{Verbatim}[frame=single, label=sintaxis para SELECT]
  <query specification> ::=
  <select core> [ { UNION [ ALL ] <select core> }... ]
  [ ORDER BY <ordering term> [ { <comma> <ordering term> }... ]
  [ LIMIT <expr> [ { OFFSET | <comma> } <expr> ] ]
  
  <select core> ::=
  SELECT [ DISTINCT | ALL ] <result column> [ { <comma><result column> }... ] 
  [ FROM <join source> ]
  [ WHERE <exp> ]
  [ GROUP BY <group list> ]
  
  <group list> ::=
  <expr> [ { <comma><expr> }... ] [ HAVING <expr> ]
  
  <result column> ::=
    <asterisk>
  | <table name><dot><asterisk>
  | <expr> [ [ AS ] <column alias> ]
  
  <join source> ::=
  <single source> [ { <join op> <single source> <join constraint> }... ]
  
  <single source> ::=
    [ <data base name> ] <table name> [ [ AS ] <table alias> ]
  | <left paren> <select stmt> <right paren> [ [ AS ] <table alias> ]
  | <left paren> <join source> <right paren>

  <join op> ::=
    <comma>
  | [ NATURAL ] [ LEFT [OUTER] | INNER | CROSS ] JOIN
  
  <join constraint> ::=
    [ ON <expr> ]
  | USING <left paren> <comma><column name> <right paren>
\end{Verbatim}

Habiendo definido un dialecto genérico que sea soportado por todos los motores a los que se le esta dando soporte teniendo en cuenta además de la sintaxis de las sentencias a los tipos de datos definidos y las funciones que presentan cada uno de los motores es necesario a continuación diseñar la arquitectura del proyecto atendiendo a las necesidades expuestas en este capitulo, actividad que se desarrollara en el siguiente capitulo. 